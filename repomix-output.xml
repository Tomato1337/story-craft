This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.env.example
.gitignore
docker-compose.db.yml
docker-compose.dev.yml
docker-compose.prod.yml
init-databases.sh
LICENSE
readme.md
services/api-gateway/.gitignore
services/api-gateway/Dockerfile.dev
services/api-gateway/Dockerfile.prod
services/api-gateway/package.json
services/api-gateway/src/app.ts
services/api-gateway/src/config.ts
services/api-gateway/src/plugins/index.ts
services/api-gateway/src/plugins/proxy.ts
services/api-gateway/src/plugins/sensible.ts
services/api-gateway/src/plugins/swagger.ts
services/api-gateway/src/types.ts
services/api-gateway/tsconfig.json
services/auth-service/.gitignore
services/auth-service/Dockerfile.dev
services/auth-service/Dockerfile.prod
services/auth-service/eslint.config.mjs
services/auth-service/package.json
services/auth-service/prisma/migrations/20250417164348_init/migration.sql
services/auth-service/prisma/migrations/20250418140707_avatar/migration.sql
services/auth-service/prisma/migrations/migration_lock.toml
services/auth-service/prisma/schema.prisma
services/auth-service/src/config.ts
services/auth-service/src/index.ts
services/auth-service/src/lib/auth.ts
services/auth-service/src/lib/prisma.ts
services/auth-service/src/middlewares/error-handler.middleware.ts
services/auth-service/src/middlewares/index.ts
services/auth-service/src/middlewares/protect-route.middleware.ts
services/auth-service/src/middlewares/validate-request.middleware.ts
services/auth-service/src/routes/auth.routes.ts
services/auth-service/src/routes/index.ts
services/auth-service/src/server.ts
services/auth-service/src/services/auth.service.ts
services/auth-service/src/types/express.d.ts
services/auth-service/src/utils/errors.ts
services/auth-service/tsconfig.json
services/common-types/package.json
services/common-types/src/auth.ts
services/common-types/src/index.ts
services/common-types/tsconfig.json
services/story-service/.gitignore
services/story-service/Dockerfile.dev
services/story-service/Dockerfile.prod
services/story-service/eslint.config.mjs
services/story-service/package.json
services/story-service/playwright.config.ts
services/story-service/prisma/migrations/20250408223425_init/migration.sql
services/story-service/prisma/migrations/20250415201339_generes/migration.sql
services/story-service/prisma/migrations/20250417164018_init/migration.sql
services/story-service/prisma/migrations/20250417183256_proposal/migration.sql
services/story-service/prisma/migrations/20250421165650_change_is_public_story/migration.sql
services/story-service/prisma/migrations/20250425204054_add_times_for_story/migration.sql
services/story-service/prisma/migrations/migration_lock.toml
services/story-service/prisma/schema.prisma
services/story-service/prisma/seed.ts
services/story-service/src/app.ts
services/story-service/src/config.ts
services/story-service/src/controllers/chapter.controller.test.ts
services/story-service/src/controllers/chapter.controller.ts
services/story-service/src/controllers/genre.controller.test.ts
services/story-service/src/controllers/genre.controller.ts
services/story-service/src/controllers/story.controller.test.ts
services/story-service/src/controllers/story.controller.ts
services/story-service/src/model/chapter.model.ts
services/story-service/src/model/genre.model.ts
services/story-service/src/model/story.model.ts
services/story-service/src/plugins/authenticate.ts
services/story-service/src/plugins/error-handler.ts
services/story-service/src/prisma.ts
services/story-service/src/routes/chapter.route.test.ts
services/story-service/src/routes/chapter.route.ts
services/story-service/src/routes/genre.route.ts
services/story-service/src/routes/index.ts
services/story-service/src/routes/story.route.test.ts
services/story-service/src/routes/story.route.ts
services/story-service/src/services/chapter.service.test.ts
services/story-service/src/services/chapter.service.ts
services/story-service/src/services/collaborator.service.test.ts
services/story-service/src/services/collaborator.service.ts
services/story-service/src/services/genre.service.ts
services/story-service/src/services/proposal.service.test.ts
services/story-service/src/services/proposal.service.ts
services/story-service/src/services/story.service.test.ts
services/story-service/src/services/story.service.ts
services/story-service/src/services/time.service.test.ts
services/story-service/src/services/time.service.ts
services/story-service/src/startup.ts
services/story-service/src/types/fastify.d.ts
services/story-service/src/utils/errors.ts
services/story-service/tests/integration/chapter-proposal.api.spec.ts
services/story-service/tests/integration/story-lifecycle.api.spec.ts
services/story-service/tests/integration/story-serivce.api.spec.ts
services/story-service/tsconfig.json
services/story-service/vitest.config.ts
services/user-profile-service/.gitignore
services/user-profile-service/app/main.go
services/user-profile-service/Dockerfile
services/user-profile-service/go.mod
services/user-profile-service/handlers/profile_handler.go
services/user-profile-service/models/profile.go
services/user-profile-service/router/router.go
services/user-profile-service/utils/database.go
start-dev.bat
start-dev.sh
start-prod.bat
start-prod.sh
stop-all.bat
stop-all.sh
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="readme.md">
# StoryCraft

Платформа для совместного творчества, где пользователи могут создавать интерактивные истории вместе.

## Архитектура

StoryCraft построен на микросервисной архитектуре с использованием разных технологий:

### TypeScript/Node.js сервисы:
- **API Gateway**: Единая точка входа для всех клиентских запросов
- **Authentication Service**: Управление аутентификацией и JWT-токенами
- **Story Management Service**: Управление интерактивными историями

### Go сервисы:
- **User Profile Service**: Управление профилями пользователей
- **Social Interaction Service**: Обработка социальных взаимодействий
- **Notification Service**: Управление уведомлениями
- **Media Service**: Работа с медиафайлами
</file>

<file path="services/api-gateway/.gitignore">
# Logs
logs
*.log
npm-debug.log*

# Runtime data
pids
*.pid
*.seed

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage

# nyc test coverage
.nyc_output

# Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# node-waf configuration
.lock-wscript

# Compiled binary addons (http://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules
jspm_packages

# Optional npm cache directory
.npm

# Optional REPL history
.node_repl_history

# 0x
profile-*

# mac files
.DS_Store

# vim swap files
*.swp

# webstorm
.idea

# vscode
.vscode
*code-workspace

# clinic
profile*
*clinic*
*flamegraph*
</file>

<file path="services/api-gateway/src/plugins/sensible.ts">
import fastifyPlugin from 'fastify-plugin'
import fastifySensible from '@fastify/sensible'
import { FastifyInstance, FastifyPluginAsync } from 'fastify'

const sensiblePlugin: FastifyPluginAsync = async (fastify: FastifyInstance) => {
    await fastify.register(fastifySensible)

    fastify.setErrorHandler((error, request, reply) => {
        fastify.log.error(error)
        return reply.send(error)
    })
}

export default fastifyPlugin(sensiblePlugin)
</file>

<file path="services/api-gateway/src/types.ts">
export interface TokenPayload {
    userId: string
    email: string
    role: string
    iat: number // issued at
    exp: number // expiration time
}
</file>

<file path="services/api-gateway/tsconfig.json">
{
    "compilerOptions": {
        "target": "ES2024", // Уровень стандартов JavaScript
        "module": "NodeNext", // Использование стандартных ES модулей
        "moduleResolution": "nodenext", // Разрешение модулей по алгоритму Node.js
        "lib": ["ES2024"], // Подключаемые библиотеки
        "outDir": "./dist", // Выходная директория для скомпилированных файлов
        "rootDir": "./src", // Корневая директория исходных файлов
        "esModuleInterop": true, // Поддержка импорта CommonJS модулей
        "strict": false,
        "forceConsistentCasingInFileNames": true, // Контроль регистра символов в путях файлов
        "skipLibCheck": true, // Пропуск проверки типов в файлах .d.ts
        "resolveJsonModule": true, // Разрешение импорта JSON модулей
        "allowJs": true // Разрешение компиляции JS файлов,
        // "allowSyntheticDefaultImports": true // Разрешение импорта модулей с экспортом по умолчанию
    },
    "include": ["src"],
    "exclude": ["node_modules", "**/*.spec.ts"]
}
</file>

<file path="services/auth-service/.gitignore">
node_modules
# Keep environment variables out of version control
.env
</file>

<file path="services/auth-service/prisma/migrations/20250417164348_init/migration.sql">
-- CreateEnum
CREATE TYPE "Role" AS ENUM ('USER', 'ADMIN');

-- CreateTable
CREATE TABLE "User" (
    "id" TEXT NOT NULL,
    "email" VARCHAR(255) NOT NULL,
    "password" VARCHAR(255) NOT NULL,
    "username" VARCHAR(255) NOT NULL,
    "role" "Role" NOT NULL DEFAULT 'USER',
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "RefreshToken" (
    "id" TEXT NOT NULL,
    "token" VARCHAR(255) NOT NULL,
    "isRevoked" BOOLEAN NOT NULL DEFAULT false,
    "revokedAt" TIMESTAMP(3),
    "revokedReason" TEXT,
    "userId" TEXT NOT NULL,
    "expiresAt" TIMESTAMP(3) NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "RefreshToken_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

-- CreateIndex
CREATE UNIQUE INDEX "User_username_key" ON "User"("username");

-- CreateIndex
CREATE UNIQUE INDEX "RefreshToken_token_key" ON "RefreshToken"("token");

-- AddForeignKey
ALTER TABLE "RefreshToken" ADD CONSTRAINT "RefreshToken_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;
</file>

<file path="services/auth-service/prisma/migrations/20250418140707_avatar/migration.sql">
-- AlterTable
ALTER TABLE "User" ADD COLUMN     "avatarUrl" TEXT;
</file>

<file path="services/auth-service/prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"
</file>

<file path="services/auth-service/src/lib/prisma.ts">
import { PrismaClient } from '@prisma/client'
import config from '../config'

declare global {
    var prisma: PrismaClient | undefined
}

export const prisma = global.prisma || new PrismaClient()
if (config.nodeEnv === 'dev') {
    global.prisma = prisma
}
</file>

<file path="services/auth-service/src/middlewares/error-handler.middleware.ts">
import { Request, Response, NextFunction } from 'express'
import { ZodError } from 'zod'
import { AppError } from '../utils/errors'
import config from '../config'

const formatZodError = (error: ZodError) => {
    return {
        message: 'Validation error',
        errors: error.errors.map((err) => ({
            field: err.path.join('.'),
            message: err.message,
        })),
    }
}

export const errorHandler = (
    err: Error,
    req: Request,
    res: Response,
    next: NextFunction
) => {
    console.error('Error:', err)

    if (err instanceof ZodError) {
        return res.status(400).json(formatZodError(err))
    }

    if (err instanceof AppError) {
        return res.status(err.statusCode).json({
            message: err.message,
            ...(config.nodeEnv === 'dev' ? { stack: err.stack } : {}),
        })
    }

    if (err.name === 'PrismaClientKnownRequestError') {
        const prismaError = err as any
        if (prismaError.code === 'P2002') {
            return res.status(409).json({
                message: 'Resource already exists',
                fields: prismaError.meta?.target || [],
            })
        }
    }

    if (err.name === 'JsonWebTokenError') {
        return res.status(401).json({ message: 'Invalid token' })
    }

    if (err.name === 'TokenExpiredError') {
        return res.status(401).json({ message: 'Token expired' })
    }

    const statusCode = 500
    const message =
        config.nodeEnv === 'production'
            ? 'Something went wrong'
            : err.message || 'Internal server error'

    return res.status(statusCode).json({
        message,
        ...(config.nodeEnv === 'dev' ? { stack: err.stack } : {}),
    })
}
</file>

<file path="services/auth-service/src/middlewares/index.ts">
import { errorHandler } from './error-handler.middleware'
import { protectRoute } from './protect-route.middleware'
import { validateRequest } from './validate-request.middleware'

export { errorHandler, protectRoute, validateRequest }
</file>

<file path="services/auth-service/src/middlewares/validate-request.middleware.ts">
import { z } from 'zod'
import { Request, Response, NextFunction } from 'express'

export const validateRequest =
    (schema: z.ZodObject<any, any>) =>
    async (req: Request, res: Response, next: NextFunction) => {
        try {
            req.body = schema.parse(req.body)
            next()
        } catch (error) {
            next(error)
        }
    }
</file>

<file path="services/auth-service/src/utils/errors.ts">
export class AppError extends Error {
    public statusCode: number
    public isOperational: boolean

    constructor(message: string, statusCode: number) {
        super(message)
        this.statusCode = statusCode
        this.isOperational = true

        Error.captureStackTrace(this, this.constructor)
    }
}

export class BadRequestError extends AppError {
    constructor(message: string) {
        super(message, 400)
    }
}

export class UnauthorizedError extends AppError {
    constructor(message: string = 'Unauthorized access') {
        super(message, 401)
    }
}

export class ForbiddenError extends AppError {
    constructor(message: string = 'Access forbidden') {
        super(message, 403)
    }
}

export class NotFoundError extends AppError {
    constructor(message: string) {
        super(message, 404)
    }
}

export class ConflictError extends AppError {
    constructor(message: string) {
        super(message, 409)
    }
}

export class InternalServerError extends AppError {
    constructor(message: string = 'Something went wrong on the server') {
        super(message, 500)
    }
}
</file>

<file path="services/common-types/src/index.ts">
export * from './auth'
</file>

<file path="services/common-types/tsconfig.json">
{
    "compilerOptions": {
        "target": "ES2020",
        "module": "commonjs",
        "declaration": true,
        "outDir": "./dist",
        "strict": true,
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true
    },
    "include": ["src"],
    "exclude": ["node_modules", "dist"]
}
</file>

<file path="services/story-service/.gitignore">
node_modules
# Keep environment variables out of version control
.env
</file>

<file path="services/story-service/eslint.config.mjs">
import globals from 'globals'
import pluginJs from '@eslint/js'
import tseslint from 'typescript-eslint'

/** @type {import('eslint').Linter.Config[]} */
export default [
    { files: ['**/*.{js,mjs,cjs,ts}'] },
    { languageOptions: { globals: globals.browser } },
    pluginJs.configs.recommended,
    ...tseslint.configs.recommended,
    {
        rules: {
            'no-var': 'off',
            '@typescript-eslint/no-namespace': 'off',
        },
    },
]
</file>

<file path="services/story-service/playwright.config.ts">
import { defineConfig } from '@playwright/test'
import { env } from './src/config.ts'

export default defineConfig({
    testDir: './tests/integration',
    timeout: 30000,
    reporter: 'html',
    use: {
        baseURL: `http://localhost:${env.PORT}`,
        extraHTTPHeaders: {
            // Добавляем заголовок для отладки
            'X-Integration-Test': 'true',
        },
        trace: 'on',
    },
    projects: [
        {
            name: 'api',
            testMatch: /.*\.api\.spec\.ts/,
        },
    ],
})
</file>

<file path="services/story-service/prisma/migrations/20250408223425_init/migration.sql">
-- CreateEnum
CREATE TYPE "Role" AS ENUM ('USER', 'ADMIN');

-- CreateTable
CREATE TABLE "Story" (
    "id" TEXT NOT NULL,
    "title" VARCHAR(255) NOT NULL,
    "description" TEXT NOT NULL,
    "genres" TEXT[],
    "coverImageUrl" VARCHAR(255) NOT NULL,
    "authorId" TEXT NOT NULL,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "isPublic" BOOLEAN NOT NULL DEFAULT false,
    "viewCount" INTEGER NOT NULL DEFAULT 0,
    "proposalDeadline" TIMESTAMP,
    "votingDeadline" TIMESTAMP,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "Story_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "StoryCollaborator" (
    "id" TEXT NOT NULL,
    "storyId" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "role" "Role" NOT NULL DEFAULT 'USER',
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "StoryCollaborator_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Chapter" (
    "id" TEXT NOT NULL,
    "title" VARCHAR(255) NOT NULL,
    "content" TEXT NOT NULL,
    "authorId" TEXT NOT NULL,
    "position" INTEGER NOT NULL,
    "isLastChapter" BOOLEAN NOT NULL DEFAULT false,
    "storyId" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "Chapter_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "ChapterProposal" (
    "id" TEXT NOT NULL,
    "title" VARCHAR(255) NOT NULL,
    "content" TEXT NOT NULL,
    "authorId" TEXT NOT NULL,
    "storyId" TEXT NOT NULL,
    "parentChapterId" TEXT NOT NULL,
    "voteCount" INTEGER NOT NULL DEFAULT 0,
    "hasWon" BOOLEAN NOT NULL DEFAULT false,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "ChapterProposal_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Vote" (
    "id" TEXT NOT NULL,
    "authorId" TEXT NOT NULL,
    "chapterProposalId" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "Vote_pkey" PRIMARY KEY ("id")
);

-- AddForeignKey
ALTER TABLE "StoryCollaborator" ADD CONSTRAINT "StoryCollaborator_storyId_fkey" FOREIGN KEY ("storyId") REFERENCES "Story"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Chapter" ADD CONSTRAINT "Chapter_storyId_fkey" FOREIGN KEY ("storyId") REFERENCES "Story"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ChapterProposal" ADD CONSTRAINT "ChapterProposal_parentChapterId_fkey" FOREIGN KEY ("parentChapterId") REFERENCES "Chapter"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Vote" ADD CONSTRAINT "Vote_chapterProposalId_fkey" FOREIGN KEY ("chapterProposalId") REFERENCES "ChapterProposal"("id") ON DELETE CASCADE ON UPDATE CASCADE;
</file>

<file path="services/story-service/prisma/migrations/20250415201339_generes/migration.sql">
/*
  Warnings:

  - You are about to drop the column `genres` on the `Story` table. All the data in the column will be lost.

*/
-- AlterEnum
ALTER TYPE "Role" ADD VALUE 'AUTHOR';

-- AlterTable
ALTER TABLE "Story" DROP COLUMN "genres";

-- CreateTable
CREATE TABLE "Genre" (
    "id" TEXT NOT NULL,
    "name" VARCHAR(255) NOT NULL,

    CONSTRAINT "Genre_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "_GenreToStory" (
    "A" TEXT NOT NULL,
    "B" TEXT NOT NULL,

    CONSTRAINT "_GenreToStory_AB_pkey" PRIMARY KEY ("A","B")
);

-- CreateIndex
CREATE INDEX "_GenreToStory_B_index" ON "_GenreToStory"("B");

-- AddForeignKey
ALTER TABLE "_GenreToStory" ADD CONSTRAINT "_GenreToStory_A_fkey" FOREIGN KEY ("A") REFERENCES "Genre"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "_GenreToStory" ADD CONSTRAINT "_GenreToStory_B_fkey" FOREIGN KEY ("B") REFERENCES "Story"("id") ON DELETE CASCADE ON UPDATE CASCADE;
</file>

<file path="services/story-service/prisma/migrations/20250417164018_init/migration.sql">
-- AlterTable
ALTER TABLE "Story" ALTER COLUMN "coverImageUrl" DROP NOT NULL;
</file>

<file path="services/story-service/prisma/migrations/20250417183256_proposal/migration.sql">
-- CreateEnum
CREATE TYPE "Phase" AS ENUM ('PROPOSAL', 'VOTING');

-- AlterTable
ALTER TABLE "Story" ADD COLUMN     "currentPhase" "Phase" NOT NULL DEFAULT 'PROPOSAL';
</file>

<file path="services/story-service/prisma/migrations/20250421165650_change_is_public_story/migration.sql">
-- AlterTable
ALTER TABLE "Story" ALTER COLUMN "isPublic" SET DEFAULT true;
</file>

<file path="services/story-service/prisma/migrations/20250425204054_add_times_for_story/migration.sql">
-- AlterTable
ALTER TABLE "Story" ADD COLUMN     "proposalTime" INTEGER NOT NULL DEFAULT 0,
ADD COLUMN     "votingTime" INTEGER NOT NULL DEFAULT 0;
</file>

<file path="services/story-service/prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"
</file>

<file path="services/story-service/src/controllers/chapter.controller.test.ts">
import { describe, it, expect, beforeEach, vi } from 'vitest'
import { chapterController } from './chapter.controller'
import { chapterStoryService } from '../services/chapter.service'
import { proposalService } from '../services/proposal.service'
import { NotFoundError, UnauthorizedError } from '../utils/errors'
import { FastifyReply, FastifyRequest } from 'fastify'

vi.mock('../services/chapter.service', () => ({
    chapterStoryService: {
        getChaptersPaginated: vi.fn(),
        getChapterById: vi.fn(),
    },
}))

vi.mock('../services/proposal.service', () => ({
    proposalService: {
        createProposeChapter: vi.fn(),
        getProposalsPaginated: vi.fn(),
        getProposalById: vi.fn(),
        voteProposal: vi.fn(),
        deleteVoteProposal: vi.fn(),
        deleteProposal: vi.fn(),
        changeProposal: vi.fn(),
        selectWinnerProposal: vi.fn(),
    },
}))

describe('chapterController', () => {
    let request: Partial<FastifyRequest>
    let reply: Partial<FastifyReply>
    beforeEach(() => {
        vi.resetAllMocks()

        reply = {
            code: vi.fn().mockReturnThis(),
            status: vi.fn().mockReturnThis(),
            send: vi.fn().mockReturnThis(),
        }
    })

    describe('getChapters', () => {
        it('должен вызывать сервис и возвращать результаты пагинации', async () => {
            const paginationResult = {
                items: [
                    {
                        id: 'chapter1',
                        title: 'Chapter 1',
                        content: '',
                        authorId: '',
                        storyId: '',
                        position: 1,
                        isLastChapter: false,
                        createdAt: new Date(),
                        updatedAt: new Date(),
                    },
                ],
                totalCount: 1,
                totalPages: 1,
                page: 1,
                pageSize: 10,
            }

            vi.mocked(
                chapterStoryService.getChaptersPaginated
            ).mockResolvedValue(paginationResult)

            request = {
                params: { storyId: 'story1' },
                query: { page: 1, pageSize: 10 },
            }

            await chapterController.getChapters(request as any, reply as any)

            expect(
                chapterStoryService.getChaptersPaginated
            ).toHaveBeenCalledWith('story1', 1, 10)
            expect(reply.code).toHaveBeenCalledWith(200)
            expect(reply.send).toHaveBeenCalledWith(paginationResult)
        })

        it('должен использовать значения по умолчанию для параметров пагинации', async () => {
            const paginationResult = {
                items: [
                    {
                        id: 'chapter1',
                        title: 'Chapter 1',
                        content: '',
                        authorId: '',
                        storyId: '',
                        position: 1,
                        isLastChapter: false,
                        createdAt: new Date(),
                        updatedAt: new Date(),
                    },
                ],
                totalCount: 1,
                totalPages: 1,
                page: 1,
                pageSize: 10,
            }
            vi.mocked(
                chapterStoryService.getChaptersPaginated
            ).mockResolvedValue(paginationResult)

            request = {
                params: { storyId: 'story1' },
                query: {},
            }

            await chapterController.getChapters(request as any, reply as any)

            expect(
                chapterStoryService.getChaptersPaginated
            ).toHaveBeenCalledWith('story1', 1, 10)
            expect(reply.code).toHaveBeenCalledWith(200)
            expect(reply.send).toHaveBeenCalledWith(paginationResult)
        })
    })

    describe('getChapterById', () => {
        it('должен вернуть главу по ID', async () => {
            const chapterData = {
                id: 'chapter1',
                title: 'Chapter 1',
                content: '',
                authorId: '',
                storyId: '',
                position: 1,
                isLastChapter: false,
                createdAt: new Date(),
                updatedAt: new Date(),
            }

            vi.mocked(chapterStoryService.getChapterById).mockResolvedValue(
                chapterData
            )

            request = {
                params: { storyId: 'story1', chapterId: 'chapter1' },
            }

            await chapterController.getChapterById(request as any, reply as any)

            expect(chapterStoryService.getChapterById).toHaveBeenCalledWith(
                'chapter1'
            )
            expect(reply.code).toHaveBeenCalledWith(200)
            expect(reply.send).toHaveBeenCalledWith(chapterData)
        })

        it('должен обработать ошибку, если глава не найдена', async () => {
            ;(chapterStoryService.getChapterById as any).mockResolvedValue(null)

            request = {
                params: { storyId: 'story1', chapterId: 'nonexistent' },
            }

            await expect(
                chapterController.getChapterById(request as any, reply as any)
            ).rejects.toThrow(NotFoundError)
            expect(chapterStoryService.getChapterById).toHaveBeenCalledWith(
                'nonexistent'
            )
        })
    })

    describe('createProposeChapter', () => {
        it('должен создавать предложение, если пользователь авторизован', async () => {
            const proposalData = {
                id: 'proposal1',
                title: 'New Chapter',
                content: 'Content',
            }
            ;(proposalService.createProposeChapter as any).mockResolvedValue(
                proposalData
            )

            request = {
                user: { userId: 'user1' },
                params: { storyId: 'story1', chapterId: 'chapter1' },
                body: { title: 'New Chapter', content: 'Content' },
            }

            await chapterController.createProposeChapter(
                request as any,
                reply as any
            )

            expect(proposalService.createProposeChapter).toHaveBeenCalledWith(
                'story1',
                'chapter1',
                'user1',
                'New Chapter',
                'Content'
            )
            expect(reply.code).toHaveBeenCalledWith(201)
            expect(reply.send).toHaveBeenCalledWith(proposalData)
        })

        it('должен выбрасывать ошибку, если пользователь не авторизован', async () => {
            request = {
                user: null,
                params: { storyId: 'story1', chapterId: 'chapter1' },
                body: { title: 'New Chapter', content: 'Content' },
            }

            await expect(
                chapterController.createProposeChapter(
                    request as any,
                    reply as any
                )
            ).rejects.toThrow(UnauthorizedError)
            expect(proposalService.createProposeChapter).not.toHaveBeenCalled()
        })
    })

    describe('getProposals', () => {
        it('должен возвращать список предложений с пагинацией', async () => {
            const paginationResult = {
                items: [{ id: 'proposal1', title: 'Proposal 1' }],
                totalCount: 1,
                totalPages: 1,
                page: 1,
                pageSize: 10,
            }
            ;(proposalService.getProposalsPaginated as any).mockResolvedValue(
                paginationResult
            )

            request = {
                params: { storyId: 'story1', chapterId: 'chapter1' },
                query: { page: 2, pageSize: 5 },
            }

            await chapterController.getProposals(request as any, reply as any)

            expect(proposalService.getProposalsPaginated).toHaveBeenCalledWith(
                'story1',
                'chapter1',
                2,
                5
            )
            expect(reply.code).toHaveBeenCalledWith(200)
            expect(reply.send).toHaveBeenCalledWith(paginationResult)
        })

        it('должен использовать значения по умолчанию для параметров пагинации', async () => {
            const paginationResult = {
                items: [{ id: 'proposal1', title: 'Proposal 1' }],
                totalCount: 1,
                totalPages: 1,
                page: 1,
                pageSize: 10,
            }
            ;(proposalService.getProposalsPaginated as any).mockResolvedValue(
                paginationResult
            )

            request = {
                params: { storyId: 'story1', chapterId: 'chapter1' },
                query: {},
            }

            await chapterController.getProposals(request as any, reply as any)

            expect(proposalService.getProposalsPaginated).toHaveBeenCalledWith(
                'story1',
                'chapter1',
                1,
                10
            )
            expect(reply.code).toHaveBeenCalledWith(200)
            expect(reply.send).toHaveBeenCalledWith(paginationResult)
        })
    })

    describe('getProposalById', () => {
        it('должен возвращать предложение по ID', async () => {
            const proposalData = { id: 'proposal1', title: 'Proposal 1' }
            ;(proposalService.getProposalById as any).mockResolvedValue(
                proposalData
            )

            request = {
                params: {
                    storyId: 'story1',
                    chapterId: 'chapter1',
                    proposalId: 'proposal1',
                },
            }

            await chapterController.getProposalById(
                request as any,
                reply as any
            )

            expect(proposalService.getProposalById).toHaveBeenCalledWith(
                'proposal1'
            )
            expect(reply.code).toHaveBeenCalledWith(200)
            expect(reply.send).toHaveBeenCalledWith(proposalData)
        })

        it('должен обработать ошибку, если предложение не найдено', async () => {
            ;(proposalService.getProposalById as any).mockResolvedValue(null)

            request = {
                params: {
                    storyId: 'story1',
                    chapterId: 'chapter1',
                    proposalId: 'nonexistent',
                },
            }

            await expect(
                chapterController.getProposalById(request as any, reply as any)
            ).rejects.toThrow(NotFoundError)
            expect(proposalService.getProposalById).toHaveBeenCalledWith(
                'nonexistent'
            )
        })
    })

    describe('voteProposal', () => {
        it('должен голосовать за предложение, если пользователь авторизован', async () => {
            const voteResult = { success: true }
            vi.mocked(proposalService.voteProposal).mockResolvedValue(
                voteResult
            )

            request = {
                user: { userId: 'user1' },
                params: { proposalId: 'proposal1' },
            }

            await chapterController.voteProposal(request as any, reply as any)

            expect(proposalService.voteProposal).toHaveBeenCalledWith(
                'proposal1',
                'user1'
            )
            expect(reply.code).toHaveBeenCalledWith(200)
            expect(reply.send).toHaveBeenCalledWith(voteResult)
        })

        it('должен выбрасывать ошибку, если пользователь не авторизован', async () => {
            request = {
                user: null,
                params: { proposalId: 'proposal1' },
            }

            await expect(
                chapterController.voteProposal(request as any, reply as any)
            ).rejects.toThrow(UnauthorizedError)
            expect(proposalService.voteProposal).not.toHaveBeenCalled()
        })
    })

    describe('deleteVoteProposal', () => {
        it('должен удалять голос, если пользователь авторизован', async () => {
            const voteResult = { success: true }
            vi.mocked(proposalService.deleteVoteProposal).mockResolvedValue(
                voteResult
            )

            request = {
                user: { userId: 'user1' },
                params: { proposalId: 'proposal1' },
            }

            await chapterController.deleteVoteProposal(
                request as any,
                reply as any
            )

            expect(proposalService.deleteVoteProposal).toHaveBeenCalledWith(
                'proposal1',
                'user1'
            )
            expect(reply.code).toHaveBeenCalledWith(204)
            expect(reply.send).toHaveBeenCalledWith(voteResult)
        })

        it('должен выбрасывать ошибку, если пользователь не авторизован', async () => {
            request = {
                user: null,
                params: { proposalId: 'proposal1' },
            }

            await expect(
                chapterController.deleteVoteProposal(
                    request as any,
                    reply as any
                )
            ).rejects.toThrow(UnauthorizedError)
            expect(proposalService.deleteVoteProposal).not.toHaveBeenCalled()
        })
    })

    describe('deleteProposalById', () => {
        it('должен удалять предложение, если пользователь авторизован', async () => {
            vi.mocked(proposalService.deleteProposal).mockResolvedValue({
                success: true,
            })

            request = {
                user: { userId: 'user1' },
                params: { storyId: 'story1', proposalId: 'proposal1' },
            }

            await chapterController.deleteProposalById(
                request as any,
                reply as any
            )

            expect(proposalService.deleteProposal).toHaveBeenCalledWith(
                'proposal1',
                'user1',
                'story1'
            )
            expect(reply.status).toHaveBeenCalledWith(204)
            expect(reply.send).toHaveBeenCalled()
        })

        it('должен выбрасывать ошибку, если пользователь не авторизован', async () => {
            request = {
                user: null,
                params: { storyId: 'story1', proposalId: 'proposal1' },
            }

            await expect(
                chapterController.deleteProposalById(
                    request as any,
                    reply as any
                )
            ).rejects.toThrow(UnauthorizedError)
            expect(proposalService.deleteProposal).not.toHaveBeenCalled()
        })
    })

    describe('changeProposalById', () => {
        it('должен изменять предложение, если пользователь авторизован', async () => {
            const updatedProposal = {
                id: 'proposal1',
                title: 'Updated Title',
                content: 'Updated Content',
            }
            ;(proposalService.changeProposal as any).mockResolvedValue(
                updatedProposal
            )

            request = {
                user: { userId: 'user1' },
                params: { storyId: 'story1', proposalId: 'proposal1' },
                body: { title: 'Updated Title', content: 'Updated Content' },
            }

            await chapterController.changeProposalById(
                request as any,
                reply as any
            )

            expect(proposalService.changeProposal).toHaveBeenCalledWith(
                'proposal1',
                'user1',
                'story1',
                'Updated Title',
                'Updated Content'
            )
            expect(reply.code).toHaveBeenCalledWith(200)
            expect(reply.send).toHaveBeenCalledWith(updatedProposal)
        })

        it('должен выбрасывать ошибку, если пользователь не авторизован', async () => {
            request = {
                user: null,
                params: { storyId: 'story1', proposalId: 'proposal1' },
                body: { title: 'Updated Title', content: 'Updated Content' },
            }

            await expect(
                chapterController.changeProposalById(
                    request as any,
                    reply as any
                )
            ).rejects.toThrow(UnauthorizedError)
            expect(proposalService.changeProposal).not.toHaveBeenCalled()
        })
    })

    describe('selectWinnerProposal', () => {
        it('должен выбирать победителя, если пользователь авторизован', async () => {
            ;(proposalService.selectWinnerProposal as any).mockResolvedValue({
                success: true,
            })

            request = {
                user: { userId: 'user1' },
                params: { proposalId: 'proposal1' },
            }

            await chapterController.selectWinnerProposal(
                request as any,
                reply as any
            )

            expect(proposalService.selectWinnerProposal).toHaveBeenCalledWith(
                'proposal1',
                'user1'
            )
            expect(reply.code).toHaveBeenCalledWith(200)
            expect(reply.send).toHaveBeenCalledWith({ success: true })
        })

        it('должен выбрасывать ошибку, если пользователь не авторизован', async () => {
            request = {
                user: null,
                params: { proposalId: 'proposal1' },
            }

            await expect(
                chapterController.selectWinnerProposal(
                    request as any,
                    reply as any
                )
            ).rejects.toThrow(UnauthorizedError)
            expect(proposalService.selectWinnerProposal).not.toHaveBeenCalled()
        })
    })
})
</file>

<file path="services/story-service/src/controllers/genre.controller.test.ts">
import { describe, it, expect, beforeEach, vi } from 'vitest'
import { genreController } from './genre.controller'
import { genreService } from '../services/genre.service'

describe('genreController', () => {
    beforeEach(() => {
        vi.resetAllMocks()
    })

    it('getAllGenres возвращает количество и список жанров', async () => {
        const fakeGenres = [{ id: 'g1', name: 'Fantasy' }]
        vi.spyOn(genreService, 'getAllGenres').mockResolvedValue(
            fakeGenres as any
        )

        const request = { log: { error: vi.fn() } } as any
        const reply = { code: vi.fn().mockReturnThis(), send: vi.fn() } as any

        await genreController.getAllGenres(request, reply)

        expect(genreService.getAllGenres).toHaveBeenCalled()
        expect(reply.code).toHaveBeenCalledWith(200)
        expect(reply.send).toHaveBeenCalledWith({
            count: 1,
            genres: fakeGenres,
        })
    })
})
</file>

<file path="services/story-service/src/controllers/story.controller.test.ts">
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { storyController } from './story.controller'
import { storyService } from '../services/story.service'
import { FastifyRequest, FastifyReply } from 'fastify'

vi.mock('../services/story.service', () => ({
    storyService: {
        createStory: vi.fn(),
        getStoryById: vi.fn(),
        updateStory: vi.fn(),
        getMyStoriesPaginated: vi.fn(),
        deleteStory: vi.fn(),
        getStoriesPaginated: vi.fn(),
    },
}))

describe('Story Controller', () => {
    let mockRequest: Partial<FastifyRequest>
    let mockReply: Partial<FastifyReply>

    beforeEach(() => {
        mockReply = {
            status: vi.fn().mockReturnThis(),
            code: vi.fn().mockReturnThis(),
            send: vi.fn().mockReturnThis(),
        }
        vi.clearAllMocks()
    })

    describe('createStory', () => {
        it('должен создавать историю и возвращать статус 201', async () => {
            const storyData = {
                title: 'Тестовая история',
                description: 'Описание тестовой истории',
                coverImageUrl: 'https://example.com/image.jpg',
                isPublic: true,
                genres: ['genre1', 'genre2'],
                initialChapter: {
                    title: 'Начальная глава',
                    content: 'Содержание начальной главы',
                },
                proposalTime: 3600000,
                votingTime: 3600000,
            }

            mockRequest = {
                body: storyData,
                user: { userId: 'user123' },
            }

            const mockStory = {
                id: 'story123',
                ...storyData,
                authorId: 'user123',
                storyCollaborators: [],
            }

            ;(storyService.createStory as any).mockResolvedValueOnce(mockStory)

            await storyController.createStory(
                mockRequest as any,
                mockReply as any
            )

            expect(storyService.createStory).toHaveBeenCalledWith(
                storyData,
                'user123'
            )
            expect(mockReply.status).toHaveBeenCalledWith(201)
            expect(mockReply.send).toHaveBeenCalledWith(mockStory)
        })
    })

    describe('getStoryById', () => {
        it('должен получать историю по идентификатору', async () => {
            const storyId = 'story123'
            mockRequest = {
                params: { storyId },
            }

            const mockStory = {
                id: storyId,
                title: 'Тестовая история',
                storyCollaborators: [],
            }

            ;(storyService.getStoryById as any).mockResolvedValueOnce(mockStory)

            await storyController.getStoryById(
                mockRequest as any,
                mockReply as any
            )

            expect(storyService.getStoryById).toHaveBeenCalledWith(storyId)
            expect(mockReply.send).toHaveBeenCalledWith(mockStory)
        })
    })

    describe('updateStoryById', () => {
        it('должен обновлять историю', async () => {
            const storyId = 'story123'
            const updateData = {
                title: 'Обновленное название',
                description: 'Обновленное описание',
                isPublic: false,
                genres: ['genre3'],
            }

            mockRequest = {
                params: { storyId },
                body: updateData,
                user: { userId: 'user123' },
            }

            const updatedStory = {
                id: storyId,
                ...updateData,
                storyCollaborators: [],
            }

            ;(storyService.updateStory as any).mockResolvedValueOnce(
                updatedStory
            )

            await storyController.updateStoryById(
                mockRequest as any,
                mockReply as any
            )

            expect(storyService.updateStory).toHaveBeenCalledWith(
                storyId,
                updateData,
                'user123'
            )
            expect(mockReply.send).toHaveBeenCalledWith(updatedStory)
        })
    })

    describe('getMyStories', () => {
        it('должен получать истории пользователя с пагинацией', async () => {
            mockRequest = {
                user: { userId: 'user123' },
                query: { page: 2, pageSize: 5 },
            }

            const mockResult = {
                items: [{ id: 'story1', title: 'История 1' }],
                totalCount: 15,
                totalPages: 3,
                page: 2,
                pageSize: 5,
            }

            ;(storyService.getMyStoriesPaginated as any).mockResolvedValueOnce(
                mockResult
            )

            await storyController.getMyStories(
                mockRequest as any,
                mockReply as any
            )

            expect(storyService.getMyStoriesPaginated).toHaveBeenCalledWith(
                'user123',
                2,
                5
            )
            expect(mockReply.send).toHaveBeenCalledWith(mockResult)
        })

        it('должен использовать стандартные значения пагинации, если они не указаны', async () => {
            mockRequest = {
                user: { userId: 'user123' },
                query: {},
            }

            const mockResult = {
                items: [{ id: 'story1', title: 'История 1' }],
                totalCount: 15,
                totalPages: 2,
                page: 1,
                pageSize: 10,
            }

            ;(storyService.getMyStoriesPaginated as any).mockResolvedValueOnce(
                mockResult
            )

            await storyController.getMyStories(
                mockRequest as any,
                mockReply as any
            )

            expect(storyService.getMyStoriesPaginated).toHaveBeenCalledWith(
                'user123',
                undefined,
                undefined
            )
            expect(mockReply.send).toHaveBeenCalledWith(mockResult)
        })
    })

    describe('deleteStoryById', () => {
        it('должен удалять историю и возвращать статус 204', async () => {
            const storyId = 'story123'
            mockRequest = {
                params: { storyId },
                user: { userId: 'user123' },
            }

            vi.mocked(storyService.deleteStory).mockResolvedValueOnce({
                success: true,
            })

            await storyController.deleteStoryById(
                mockRequest as any,
                mockReply as any
            )

            expect(storyService.deleteStory).toHaveBeenCalledWith(
                storyId,
                'user123'
            )
            expect(mockReply.status).toHaveBeenCalledWith(204)
            expect(mockReply.send).toHaveBeenCalledWith({ success: true })
        })
    })

    describe('getAllStory', () => {
        it('должен получать все истории с пагинацией', async () => {
            mockRequest = {
                user: { userId: 'user123' },
                query: { page: 2, pageSize: 5 },
            }

            const mockResult = {
                items: [{ id: 'story1', title: 'История 1' }],
                totalCount: 15,
                totalPages: 3,
                page: 2,
                pageSize: 5,
            }

            ;(storyService.getStoriesPaginated as any).mockResolvedValueOnce(
                mockResult
            )

            await storyController.getAllStory(
                mockRequest as any,
                mockReply as any
            )

            expect(storyService.getStoriesPaginated).toHaveBeenCalledWith(
                2,
                5,
                'user123'
            )
            expect(mockReply.code).toHaveBeenCalledWith(200)
            expect(mockReply.send).toHaveBeenCalledWith(mockResult)
        })

        it('должен обрабатывать случай, когда пользователь не аутентифицирован', async () => {
            mockRequest = {
                user: undefined,
                query: { page: 1, pageSize: 10 },
            }

            const mockResult = {
                items: [{ id: 'story1', title: 'История 1' }],
                totalCount: 10,
                totalPages: 1,
                page: 1,
                pageSize: 10,
            }

            ;(storyService.getStoriesPaginated as any).mockResolvedValueOnce(
                mockResult
            )

            await storyController.getAllStory(
                mockRequest as any,
                mockReply as any
            )

            expect(storyService.getStoriesPaginated).toHaveBeenCalledWith(
                1,
                10,
                undefined
            )
            expect(mockReply.code).toHaveBeenCalledWith(200)
            expect(mockReply.send).toHaveBeenCalledWith(mockResult)
        })
    })
})
</file>

<file path="services/story-service/src/plugins/error-handler.ts">
import { FastifyError, FastifyInstance } from 'fastify'
import fp from 'fastify-plugin'
import { AppError } from '../utils/errors'
import { PrismaClientKnownRequestError } from '@prisma/client/runtime/library'
import {
    hasZodFastifySchemaValidationErrors,
    isResponseSerializationError,
} from 'fastify-type-provider-zod'
import { env } from '../config'

export default fp(async (fastify: FastifyInstance) => {
    fastify.setErrorHandler((error: FastifyError, request, reply) => {
        fastify.log.error(error)

        if (error instanceof AppError) {
            return reply.status(error.statusCode).send({
                error: error.constructor.name,
                message: error.message,
                statusCode: error.statusCode,
            })
        }

        if (hasZodFastifySchemaValidationErrors(error)) {
            return reply.status(400).send({
                error: 'ValidationError',
                message: error.message,
                statusCode: 400,
                details: {
                    issues: error.validation,
                    method: request.method,
                    url: request.url,
                },
            })
        }

        if (isResponseSerializationError(error)) {
            return reply.code(500).send({
                error: 'Internal Server Error',
                message: "Response doesn't match the schema",
                statusCode: 500,
                details: {
                    issues: error.cause.issues,
                    method: error.method,
                    url: error.url,
                },
            })
        }

        if (error instanceof PrismaClientKnownRequestError) {
            let statusCode = 500
            let message = 'Ошибка базы данных'

            switch (error.code) {
                case 'P2001': // Запись не найдена
                case 'P2025': // Запись не найдена или условное ограничение не выполнено
                    statusCode = 404
                    message = 'Запрашиваемый ресурс не найден'
                    break
                case 'P2002': // Уникальное ограничение нарушено
                    statusCode = 409
                    message = 'Ресурс с такими данными уже существует'
                    break
                case 'P2003': // Нарушение ограничения внешнего ключа
                    statusCode = 400
                    message = 'Ссылка на несуществующий ресурс'
                    break
                case 'P2014': // Нарушение ограничения отношения
                    statusCode = 400
                    message = 'Некорректная связь между ресурсами'
                    break
            }

            return reply.status(statusCode).send({
                error: 'DatabaseError',
                code: error.code,
                message,
                statusCode,
            })
        }

        const statusCode = error.statusCode || error?.status || 500

        const errorResponse = {
            error: error.name || 'InternalServerError',
            message: error.message || 'Внутренняя ошибка сервера',
            statusCode: statusCode,
            ...(env.NODE_ENV === 'prod' ? {} : { stack: error.stack }),
        }

        reply.status(statusCode).send(errorResponse)
    })
})
</file>

<file path="services/story-service/src/prisma.ts">
import { PrismaClient, Role, Phase } from '@prisma/client'
import { env } from './config'

declare global {
    var prisma: PrismaClient | undefined
}
export const prisma = global.prisma || new PrismaClient()
if (env.NODE_ENV === 'dev') {
    global.prisma = prisma
}

export { Role, Phase }
</file>

<file path="services/story-service/src/routes/chapter.route.test.ts">
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { chapterRoutes } from './chapter.route'
import { chapterController } from '../controllers/chapter.controller'
import z from 'zod'

const mockFastifyApp = {
    route: vi.fn(),
    authenticate: 'authenticateMiddleware',
    withTypeProvider: vi.fn().mockReturnThis(),
}

vi.mock('../controllers/chapter.controller', () => ({
    chapterController: {
        getChapters: 'getChaptersHandler',
        getChapterById: 'getChapterByIdHandler',
        createProposeChapter: 'createProposeChapterHandler',
        deleteProposalById: 'deleteProposalByIdHandler',
        changeProposalById: 'changeProposalByIdHandler',
        getProposals: 'getProposalsHandler',
        getProposalById: 'getProposalByIdHandler',
        voteProposal: 'voteProposalHandler',
        deleteVoteProposal: 'deleteVoteProposalHandler',
        selectWinnerProposal: 'selectWinnerProposalHandler',
    },
}))

vi.mock('../model/chapter.model', () => ({
    proposeChapterSchema: 'proposeChapterSchema',
    proposalResponseSchema: 'proposalResponseSchema',
    voteResponseSchema: 'voteResponseSchema',
    paginatedChapterResponseSchema: 'paginatedChapterResponseSchema',
    paginatedProposalResponseSchema: 'paginatedProposalResponseSchema',
    createChapterSchema: 'createChapterSchema',
    chapterResponseSchema: 'chapterResponseSchema',
}))

describe('Chapter Routes', () => {
    beforeEach(() => {
        vi.clearAllMocks()
    })

    it('должен зарегистрировать все маршруты для глав', async () => {
        await chapterRoutes(mockFastifyApp as any, {} as any)

        expect(mockFastifyApp.route).toHaveBeenCalledTimes(10)
        expect(mockFastifyApp.withTypeProvider).toHaveBeenCalledTimes(10)
    })

    it('должен правильно зарегистрировать маршрут GET /:storyId/chapters', async () => {
        await chapterRoutes(mockFastifyApp as any, {} as any)

        const getChaptersRoute = mockFastifyApp.route.mock.calls[0][0]
        expect(getChaptersRoute).toMatchObject({
            method: 'GET',
            url: '/:storyId/chapters',
            handler: chapterController.getChapters,
        })

        expect(getChaptersRoute.schema.tags).toContain('Stories')
        expect(getChaptersRoute.schema.params).toBeInstanceOf(z.ZodObject)
        expect(getChaptersRoute.schema.querystring).toBeInstanceOf(z.ZodObject)
        expect(getChaptersRoute.schema.response[200]).toBe(
            'paginatedChapterResponseSchema'
        )
    })

    it('должен правильно зарегистрировать маршрут GET /:storyId/chapters/:chapterId', async () => {
        await chapterRoutes(mockFastifyApp as any, {} as any)

        const getChapterByIdRoute = mockFastifyApp.route.mock.calls[1][0]
        expect(getChapterByIdRoute).toMatchObject({
            method: 'GET',
            url: '/:storyId/chapters/:chapterId',
            handler: chapterController.getChapterById,
        })

        expect(getChapterByIdRoute.schema.params).toBeInstanceOf(z.ZodObject)
        expect(getChapterByIdRoute.schema.response[200]).toBe(
            'chapterResponseSchema'
        )
    })

    it('должен правильно зарегистрировать маршрут POST /:storyId/chapters/:chapterId/proposals', async () => {
        await chapterRoutes(mockFastifyApp as any, {} as any)

        const createProposeChapterRoute = mockFastifyApp.route.mock.calls[2][0]
        expect(createProposeChapterRoute).toMatchObject({
            method: 'POST',
            url: '/:storyId/chapters/:chapterId/proposals',
            preValidation: [mockFastifyApp.authenticate],
            handler: chapterController.createProposeChapter,
        })

        expect(createProposeChapterRoute.schema.security).toContainEqual({
            bearerAuth: [],
        })
        expect(createProposeChapterRoute.schema.params).toBeInstanceOf(
            z.ZodObject
        )
        expect(createProposeChapterRoute.schema.body).toBe(
            'proposeChapterSchema'
        )
        expect(createProposeChapterRoute.schema.response[201]).toBe(
            'proposalResponseSchema'
        )
    })

    it('должен правильно зарегистрировать маршрут DELETE /:storyId/chapters/:chapterId/proposals/:proposalId', async () => {
        await chapterRoutes(mockFastifyApp as any, {} as any)

        const deleteProposalRoute = mockFastifyApp.route.mock.calls[3][0]
        expect(deleteProposalRoute).toMatchObject({
            method: 'DELETE',
            url: '/:storyId/chapters/:chapterId/proposals/:proposalId',
            preValidation: [mockFastifyApp.authenticate],
            handler: chapterController.deleteProposalById,
        })

        expect(deleteProposalRoute.schema.security).toContainEqual({
            bearerAuth: [],
        })
        expect(deleteProposalRoute.schema.params).toBeInstanceOf(z.ZodObject)
        expect(deleteProposalRoute.schema.response[204].shape).toHaveProperty(
            'status'
        )
    })

    it('должен правильно зарегистрировать маршрут PATCH /:storyId/chapters/:chapterId/proposals/:proposalId', async () => {
        await chapterRoutes(mockFastifyApp as any, {} as any)

        const changeProposalRoute = mockFastifyApp.route.mock.calls[4][0]
        expect(changeProposalRoute).toMatchObject({
            method: 'PATCH',
            url: '/:storyId/chapters/:chapterId/proposals/:proposalId',
            preValidation: [mockFastifyApp.authenticate],
            handler: chapterController.changeProposalById,
        })

        expect(changeProposalRoute.schema.security).toContainEqual({
            bearerAuth: [],
        })
        expect(changeProposalRoute.schema.params).toBeInstanceOf(z.ZodObject)
        expect(changeProposalRoute.schema.body).toBe('createChapterSchema')
        expect(changeProposalRoute.schema.response[204]).toBe(
            'proposalResponseSchema'
        )
    })

    it('должен правильно зарегистрировать маршрут GET /:storyId/chapters/:chapterId/proposals', async () => {
        await chapterRoutes(mockFastifyApp as any, {} as any)

        const getProposalsRoute = mockFastifyApp.route.mock.calls[5][0]
        expect(getProposalsRoute).toMatchObject({
            method: 'GET',
            url: '/:storyId/chapters/:chapterId/proposals',
            handler: chapterController.getProposals,
        })

        expect(getProposalsRoute.schema.params).toBeInstanceOf(z.ZodObject)
        expect(getProposalsRoute.schema.querystring).toBeInstanceOf(z.ZodObject)
        expect(getProposalsRoute.schema.response[200]).toBe(
            'paginatedProposalResponseSchema'
        )
    })

    it('должен правильно зарегистрировать маршрут GET /:storyId/chapters/:chapterId/proposals/:proposalId', async () => {
        await chapterRoutes(mockFastifyApp as any, {} as any)

        const getProposalByIdRoute = mockFastifyApp.route.mock.calls[6][0]
        expect(getProposalByIdRoute).toMatchObject({
            method: 'GET',
            url: '/:storyId/chapters/:chapterId/proposals/:proposalId',
            handler: chapterController.getProposalById,
        })

        expect(getProposalByIdRoute.schema.params).toBeInstanceOf(z.ZodObject)
        expect(getProposalByIdRoute.schema.response[200]).toBe(
            'proposalResponseSchema'
        )
    })

    it('должен правильно зарегистрировать маршрут POST /proposals/:proposalId/vote', async () => {
        await chapterRoutes(mockFastifyApp as any, {} as any)

        const voteProposalRoute = mockFastifyApp.route.mock.calls[7][0]
        expect(voteProposalRoute).toMatchObject({
            method: 'POST',
            url: '/proposals/:proposalId/vote',
            preValidation: [mockFastifyApp.authenticate],
            handler: chapterController.voteProposal,
        })

        expect(voteProposalRoute.schema.security).toContainEqual({
            bearerAuth: [],
        })
        expect(voteProposalRoute.schema.params).toBeInstanceOf(z.ZodObject)
        expect(voteProposalRoute.schema.response[200]).toBe(
            'voteResponseSchema'
        )
    })

    it('должен правильно зарегистрировать маршрут DELETE /proposals/:proposalId/vote', async () => {
        await chapterRoutes(mockFastifyApp as any, {} as any)

        const deleteVoteRoute = mockFastifyApp.route.mock.calls[8][0]
        expect(deleteVoteRoute).toMatchObject({
            method: 'DELETE',
            url: '/proposals/:proposalId/vote',
            preValidation: [mockFastifyApp.authenticate],
            handler: chapterController.deleteVoteProposal,
        })

        expect(deleteVoteRoute.schema.security).toContainEqual({
            bearerAuth: [],
        })
        expect(deleteVoteRoute.schema.params).toBeInstanceOf(z.ZodObject)
        expect(deleteVoteRoute.schema.response[200]).toBe('voteResponseSchema')
    })

    it('должен правильно зарегистрировать маршрут POST /proposals/:proposalId/select-winner', async () => {
        await chapterRoutes(mockFastifyApp as any, {} as any)

        const selectWinnerRoute = mockFastifyApp.route.mock.calls[9][0]
        expect(selectWinnerRoute).toMatchObject({
            method: 'POST',
            url: '/proposals/:proposalId/select-winner',
            preValidation: [mockFastifyApp.authenticate],
            handler: chapterController.selectWinnerProposal,
        })

        expect(selectWinnerRoute.schema.security).toContainEqual({
            bearerAuth: [],
        })
        expect(selectWinnerRoute.schema.params).toBeInstanceOf(z.ZodObject)
        expect(selectWinnerRoute.schema.response[200]).toBe(
            'proposalResponseSchema'
        )
    })
})
</file>

<file path="services/story-service/src/routes/story.route.test.ts">
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { storyRoutes } from './story.route'
import { storyController } from '../controllers/story.controller'
import z from 'zod'

const mockFastifyApp = {
    route: vi.fn(),
    authenticate: 'authenticateMiddleware',
    authenticateOptional: 'authenticateOptionalMiddleware',
    withTypeProvider: vi.fn().mockReturnThis(),
}

vi.mock('../controllers/story.controller', () => ({
    storyController: {
        getAllStory: 'getAllStoryHandler',
        getMyStories: 'getMyStoriesHandler',
        createStory: 'createStoryHandler',
        getStoryById: 'getStoryByIdHandler',
        updateStoryById: 'updateStoryByIdHandler',
        deleteStoryById: 'deleteStoryByIdHandler',
    },
}))

vi.mock('../model/story.model', () => ({
    createStorySchema: 'createStorySchema',
    paginatedStoryResponseSchema: 'paginatedStoryResponseSchema',
    storyResponseSchema: 'storyResponseSchema',
    updateStorySchema: 'updateStorySchema',
}))

describe('Story Routes', () => {
    beforeEach(() => {
        vi.clearAllMocks()
    })

    it('должен зарегистрировать все маршруты для историй', async () => {
        await storyRoutes(mockFastifyApp as any, {} as any)

        expect(mockFastifyApp.route).toHaveBeenCalledTimes(6)
        expect(mockFastifyApp.withTypeProvider).toHaveBeenCalledTimes(6)
    })

    it('должен правильно зарегистрировать маршрут GET / для всех историй', async () => {
        await storyRoutes(mockFastifyApp as any, {} as any)

        const getAllStoriesRoute = mockFastifyApp.route.mock.calls[0][0]
        expect(getAllStoriesRoute).toMatchObject({
            method: 'GET',
            url: '/',
            preValidation: [mockFastifyApp.authenticateOptional],
            handler: storyController.getAllStory,
        })

        expect(getAllStoriesRoute.schema.tags).toContain('Stories')
        expect(getAllStoriesRoute.schema.querystring).toBeInstanceOf(
            z.ZodObject
        )
        expect(getAllStoriesRoute.schema.response[200]).toBe(
            'paginatedStoryResponseSchema'
        )
    })

    it('должен правильно зарегистрировать маршрут GET /my для пользовательских историй', async () => {
        await storyRoutes(mockFastifyApp as any, {} as any)

        const getMyStoriesRoute = mockFastifyApp.route.mock.calls[1][0]
        expect(getMyStoriesRoute).toMatchObject({
            method: 'GET',
            url: '/my',
            preValidation: [mockFastifyApp.authenticate],
            handler: storyController.getMyStories,
        })

        expect(getMyStoriesRoute.schema.security).toContainEqual({
            bearerAuth: [],
        })
        expect(getMyStoriesRoute.schema.response[200]).toBe(
            'paginatedStoryResponseSchema'
        )
    })

    it('должен правильно зарегистрировать маршрут POST / для создания истории', async () => {
        await storyRoutes(mockFastifyApp as any, {} as any)

        const createStoryRoute = mockFastifyApp.route.mock.calls[2][0]
        expect(createStoryRoute).toMatchObject({
            method: 'POST',
            url: '/',
            preValidation: [mockFastifyApp.authenticate],
            handler: storyController.createStory,
        })

        expect(createStoryRoute.schema.body).toBe('createStorySchema')
        expect(createStoryRoute.schema.security).toContainEqual({
            bearerAuth: [],
        })
        expect(createStoryRoute.schema.response[200]).toBe(
            'storyResponseSchema'
        )
    })

    it('должен правильно зарегистрировать маршрут GET /:storyId для получения истории по ID', async () => {
        await storyRoutes(mockFastifyApp as any, {} as any)

        const getStoryByIdRoute = mockFastifyApp.route.mock.calls[3][0]
        expect(getStoryByIdRoute).toMatchObject({
            method: 'GET',
            url: '/:storyId',
            handler: storyController.getStoryById,
        })

        expect(getStoryByIdRoute.schema.params).toBeInstanceOf(z.ZodObject)
        expect(getStoryByIdRoute.schema.response[200]).toBe(
            'storyResponseSchema'
        )
    })

    it('должен правильно зарегистрировать маршрут PATCH /:storyId для обновления истории', async () => {
        await storyRoutes(mockFastifyApp as any, {} as any)

        const updateStoryRoute = mockFastifyApp.route.mock.calls[4][0]
        expect(updateStoryRoute).toMatchObject({
            method: 'PATCH',
            url: '/:storyId',
            preValidation: [mockFastifyApp.authenticate],
            handler: storyController.updateStoryById,
        })

        expect(updateStoryRoute.schema.body).toBe('updateStorySchema')
        expect(updateStoryRoute.schema.security).toContainEqual({
            bearerAuth: [],
        })
        expect(updateStoryRoute.schema.response[200]).toBe(
            'storyResponseSchema'
        )
    })

    it('должен правильно зарегистрировать маршрут DELETE /:storyId для удаления истории', async () => {
        await storyRoutes(mockFastifyApp as any, {} as any)

        const deleteStoryRoute = mockFastifyApp.route.mock.calls[5][0]
        expect(deleteStoryRoute).toMatchObject({
            method: 'DELETE',
            url: '/:storyId',
            preValidation: [mockFastifyApp.authenticate],
            handler: storyController.deleteStoryById,
        })

        expect(deleteStoryRoute.schema.params).toBeInstanceOf(z.ZodObject)
        expect(deleteStoryRoute.schema.security).toContainEqual({
            bearerAuth: [],
        })
        expect(deleteStoryRoute.schema.response[204].shape).toHaveProperty(
            'success'
        )
    })
})
</file>

<file path="services/story-service/src/services/chapter.service.test.ts">
import { describe, it, expect, beforeEach, vi } from 'vitest'
import { chapterStoryService } from './chapter.service'
import { prisma } from '../prisma'
import { NotFoundError } from '../utils/errors'

vi.mock('../prisma', () => ({
    prisma: {
        story: {
            count: vi.fn(),
            findMany: vi.fn(),
            findUnique: vi.fn(),
        },
        chapter: {
            count: vi.fn(),
            findMany: vi.fn(),
            findUnique: vi.fn(),
            create: vi.fn(),
        },
    },
}))

describe('chapterStoryService', () => {
    beforeEach(() => {
        vi.resetAllMocks()
    })

    describe('createChapter', () => {
        it('должен создавать новую главу с правильными данными', async () => {
            const now = new Date()
            const storyId = 'story1'
            const authorId = 'author1'
            const chapterData = {
                title: 'Новая глава',
                content: 'Содержание новой главы',
            }

            ;(prisma.story.findUnique as any).mockResolvedValue({ id: storyId })
            ;(prisma.chapter.count as any).mockResolvedValue(3)
            const createdChapter = {
                id: 'chapter1',
                title: chapterData.title,
                content: chapterData.content,
                authorId,
                storyId,
                position: 4,
                isLastChapter: true,
                createdAt: now,
                updatedAt: now,
            }
            ;(prisma.chapter.create as any).mockResolvedValue(createdChapter)

            const result = await chapterStoryService.createChapter(
                storyId,
                chapterData,
                authorId
            )

            expect(prisma.story.findUnique).toHaveBeenCalledWith({
                where: { id: storyId },
            })
            expect(prisma.chapter.count).toHaveBeenCalledWith({
                where: { storyId },
            })
            expect(prisma.chapter.create).toHaveBeenCalledWith({
                data: {
                    title: chapterData.title,
                    content: chapterData.content,
                    authorId,
                    storyId,
                    position: 4, // 3 + 1
                    isLastChapter: true,
                },
            })
            expect(result).toEqual(createdChapter)
        })

        it('должен выбросить ошибку, если история не найдена', async () => {
            const storyId = 'nonexistent'

            ;(prisma.story.findUnique as any).mockResolvedValue(null)

            await expect(
                chapterStoryService.createChapter(
                    storyId,
                    { title: 'Тест', content: 'Контент' },
                    'author1'
                )
            ).rejects.toThrow(NotFoundError)
            expect(prisma.story.findUnique).toHaveBeenCalledWith({
                where: { id: storyId },
            })
            expect(prisma.chapter.create).not.toHaveBeenCalled()
        })
    })

    describe('getChapterById', () => {
        it('должен возвращать главу по ID', async () => {
            const now = new Date()
            const chapterId = 'chapter1'
            const chapterData = {
                id: chapterId,
                title: 'Тестовая глава',
                content: 'Содержание главы',
                authorId: 'author1',
                storyId: 'story1',
                position: 1,
                isLastChapter: true,
                createdAt: now,
                updatedAt: now,
            }

            ;(prisma.chapter.findUnique as any).mockResolvedValue(chapterData)

            const result = await chapterStoryService.getChapterById(chapterId)

            expect(prisma.chapter.findUnique).toHaveBeenCalledWith({
                where: { id: chapterId },
            })
            expect(result).toEqual(chapterData)
        })

        it('должен выбросить ошибку, если глава не найдена', async () => {
            const chapterId = 'nonexistent'

            ;(prisma.chapter.findUnique as any).mockResolvedValue(null)

            await expect(
                chapterStoryService.getChapterById(chapterId)
            ).rejects.toThrow(NotFoundError)
            expect(prisma.chapter.findUnique).toHaveBeenCalledWith({
                where: { id: chapterId },
            })
        })
    })

    describe('getChaptersPaginated', () => {
        it('должен возвращать корректную пагинацию и вызовы prisma', async () => {
            const now = new Date()
            const fakeChapters = [
                { id: 'c1', createdAt: now, updatedAt: now },
                { id: 'c2', createdAt: now, updatedAt: now },
                { id: 'c3', createdAt: now, updatedAt: now },
                { id: 'c4', createdAt: now, updatedAt: now },
                { id: 'c5', createdAt: now, updatedAt: now },
            ]
            ;(prisma.story.findUnique as any).mockResolvedValue({
                id: 'story1',
            })
            ;(prisma.chapter.count as any).mockResolvedValue(5)
            ;(prisma.chapter.findMany as any).mockResolvedValue(fakeChapters)

            const result = await chapterStoryService.getChaptersPaginated(
                'story1',
                2,
                2
            )

            expect(prisma.chapter.count).toHaveBeenCalledWith({
                where: { storyId: 'story1' },
            })
            expect(prisma.chapter.findMany).toHaveBeenCalledWith({
                where: { storyId: 'story1' },
                orderBy: { position: 'asc' },
                skip: 2,
                take: 2,
            })
            expect(result).toEqual({
                items: fakeChapters,
                totalCount: 5,
                totalPages: Math.ceil(5 / 2),
                page: 2,
                pageSize: 2,
            })
        })

        it('должен выбросить ошибку, если история не найдена', async () => {
            const storyId = 'nonexistent'
            // Настраиваем моки
            ;(prisma.story.findUnique as any).mockResolvedValue(null)

            // Проверяем, что метод выбрасывает ошибку
            await expect(
                chapterStoryService.getChaptersPaginated(storyId)
            ).rejects.toThrow(NotFoundError)
            expect(prisma.story.findUnique).toHaveBeenCalledWith({
                where: { id: storyId },
            })
            expect(prisma.chapter.findMany).not.toHaveBeenCalled()
        })
    })
})
</file>

<file path="services/story-service/src/services/collaborator.service.test.ts">
import { describe, it, expect, beforeEach, vi } from 'vitest'
import { collaboratorService } from './collaborator.service'
import { prisma } from '../prisma'

// Мок для prisma
vi.mock('../prisma', () => {
    return {
        prisma: {
            storyCollaborator: {
                findMany: vi.fn(),
                findFirst: vi.fn(),
                create: vi.fn(),
            },
        },
    }
})

describe('collaboratorService', () => {
    beforeEach(() => {
        vi.resetAllMocks()
    })

    describe('getStoryCollaborators', () => {
        it('должен возвращать список соавторов истории', async () => {
            const mockCollaborators = [
                { id: '1', userId: 'user1', storyId: 'story1', role: 'ADMIN' },
                { id: '2', userId: 'user2', storyId: 'story1', role: 'USER' },
            ]

            ;(prisma.storyCollaborator.findMany as any).mockResolvedValue(
                mockCollaborators
            )

            const result = await collaboratorService.getStoryCollaborators(
                'story1'
            )

            expect(prisma.storyCollaborator.findMany).toHaveBeenCalledWith({
                where: { storyId: 'story1' },
            })

            expect(result).toEqual([
                { id: '1', userId: 'user1', role: 'ADMIN' },
                { id: '2', userId: 'user2', role: 'USER' },
            ])
        })
    })

    describe('addCollaboratorInStory', () => {
        it('должен добавлять нового соавтора, если он не существует', async () => {
            ;(prisma.storyCollaborator.findFirst as any).mockResolvedValue(null)

            const newCollaborator = {
                id: '3',
                userId: 'user3',
                storyId: 'story1',
                role: 'USER',
            }

            ;(prisma.storyCollaborator.create as any).mockResolvedValue(
                newCollaborator
            )

            const result = await collaboratorService.addCollaboratorInStory(
                'story1',
                'user3'
            )

            expect(prisma.storyCollaborator.findFirst).toHaveBeenCalledWith({
                where: {
                    storyId: 'story1',
                    userId: 'user3',
                },
            })

            expect(prisma.storyCollaborator.create).toHaveBeenCalledWith({
                data: {
                    storyId: 'story1',
                    userId: 'user3',
                },
            })

            expect(result).toEqual(newCollaborator)
        })

        it('должен возвращать существующего соавтора, если он уже существует', async () => {
            const existingCollaborator = {
                id: '2',
                userId: 'user2',
                storyId: 'story1',
                role: 'USER',
            }

            ;(prisma.storyCollaborator.findFirst as any).mockResolvedValue(
                existingCollaborator
            )

            const result = await collaboratorService.addCollaboratorInStory(
                'story1',
                'user2'
            )

            expect(prisma.storyCollaborator.findFirst).toHaveBeenCalledWith({
                where: {
                    storyId: 'story1',
                    userId: 'user2',
                },
            })

            expect(prisma.storyCollaborator.create).not.toHaveBeenCalled()

            expect(result).toEqual(existingCollaborator)
        })
    })
})
</file>

<file path="services/story-service/src/services/genre.service.ts">
import { CreateGenreInput } from '../model/genre.model'
import { prisma } from '../prisma'

export const genreService = {
    async createGenre(data: CreateGenreInput) {
        return prisma.genre.create({
            data,
        })
    },

    async getGenreById(id: string) {
        return prisma.genre.findUnique({
            where: { id },
        })
    },

    async updateGenre(id: string, data: Partial<CreateGenreInput>) {
        return prisma.genre.update({
            where: { id },
            data,
        })
    },

    async deleteGenre(id: string) {
        return prisma.genre.delete({
            where: { id },
        })
    },

    async getAllGenres() {
        return prisma.genre.findMany()
    },
}
</file>

<file path="services/story-service/src/services/proposal.service.test.ts">
import { describe, it, expect, beforeEach, vi } from 'vitest'
import { proposalService } from './proposal.service'
import { prisma, Phase } from '../prisma'
import { chapterStoryService } from './chapter.service'
import { collaboratorService } from './collaborator.service'
import { TimerService } from './time.service'
import { ConflictError, ForbiddenError, NotFoundError } from '../utils/errors'

vi.mock('../prisma', () => ({
    prisma: {
        chapterProposal: {
            count: vi.fn(),
            findMany: vi.fn(),
            create: vi.fn(),
            findUnique: vi.fn(),
            update: vi.fn(),
            deleteMany: vi.fn(),
            delete: vi.fn(),
        },
        chapter: {
            findFirst: vi.fn(),
            updateMany: vi.fn(),
        },
        story: {
            findUnique: vi.fn(),
            update: vi.fn(),
        },
        storyCollaborator: {
            findFirst: vi.fn(),
        },
        vote: {
            findFirst: vi.fn(),
            create: vi.fn(),
            delete: vi.fn(),
        },
    },
    Phase: {
        PROPOSAL: 'PROPOSAL',
        VOTING: 'VOTING',
    },
}))

vi.mock('./chapter.service', () => ({
    chapterStoryService: {
        createChapter: vi.fn(),
    },
}))

vi.mock('./collaborator.service', () => ({
    collaboratorService: {
        addCollaboratorInStory: vi.fn(),
    },
}))

vi.mock('./time.service', () => ({
    TimerService: {
        setProposalTimer: vi.fn(),
        setVotingTimer: vi.fn(),
    },
}))

describe('proposalService', () => {
    beforeEach(() => {
        vi.resetAllMocks()
    })

    describe('getProposalsPaginated', () => {
        it('должен возвращать корректные данные и флаг hasWon=false', async () => {
            const now = new Date()
            const fakeProps = [
                {
                    id: 'p1',
                    voteCount: 0,
                    storyId: 's1',
                    parentChapterId: 'c1',
                    authorId: 'u1',
                    title: 't1',
                    content: 'c1',
                    createdAt: now,
                    updatedAt: now,
                },
                {
                    id: 'p2',
                    voteCount: 2,
                    storyId: 's1',
                    parentChapterId: 'c1',
                    authorId: 'u1',
                    title: 't2',
                    content: 'c2',
                    createdAt: now,
                    updatedAt: now,
                },
            ]
            ;(prisma.chapterProposal.count as any).mockResolvedValue(2)
            ;(prisma.chapterProposal.findMany as any).mockResolvedValue(
                fakeProps
            )

            const result = await proposalService.getProposalsPaginated(
                's1',
                'c1',
                1,
                10
            )

            expect(prisma.chapterProposal.count).toHaveBeenCalledWith({
                where: { storyId: 's1', parentChapterId: 'c1' },
            })
            expect(prisma.chapterProposal.findMany).toHaveBeenCalledWith({
                where: { storyId: 's1', parentChapterId: 'c1' },
                orderBy: { createdAt: 'asc' },
                skip: 0,
                take: 10,
            })
            expect(result).toEqual({
                items: fakeProps.map((p) => ({
                    ...p,
                    hasWon: false,
                })),
                totalCount: 2,
                totalPages: 1,
                page: 1,
                pageSize: 10,
            })
        })
    })

    describe('createProposeChapter', () => {
        it('должен создавать новое предложение для главы', async () => {
            const now = new Date()
            const lastChapter = {
                id: 'c1',
                storyId: 's1',
                isLastChapter: true,
                position: 1,
            }
            const story = {
                id: 's1',
                currentPhase: Phase.PROPOSAL,
                proposalTime: 60000,
            }
            const proposal = {
                id: 'p1',
                storyId: 's1',
                parentChapterId: 'c1',
                authorId: 'u1',
                title: 'New Chapter',
                content: 'Chapter content',
                voteCount: 0,
                createdAt: now,
                updatedAt: now,
            }

            vi.mocked(prisma.chapter.findFirst).mockResolvedValue(
                lastChapter as any
            )
            vi.mocked(prisma.story.findUnique).mockResolvedValue(story as any)
            vi.mocked(prisma.chapterProposal.create).mockResolvedValue(
                proposal as any
            )
            vi.mocked(prisma.chapterProposal.count).mockResolvedValue(2)

            const result = await proposalService.createProposeChapter(
                's1',
                'c1',
                'u1',
                'New Chapter',
                'Chapter content'
            )

            expect(prisma.chapter.findFirst).toHaveBeenCalledWith({
                where: { storyId: 's1', isLastChapter: true },
                orderBy: { position: 'desc' },
            })
            expect(prisma.story.findUnique).toHaveBeenCalledWith({
                where: { id: 's1' },
            })
            expect(prisma.chapterProposal.create).toHaveBeenCalledWith({
                data: {
                    storyId: 's1',
                    parentChapterId: 'c1',
                    authorId: 'u1',
                    title: 'New Chapter',
                    content: 'Chapter content',
                },
            })
            expect(prisma.chapterProposal.count).toHaveBeenCalledWith({
                where: { storyId: 's1' },
            })
            expect(prisma.story.update).toHaveBeenCalled()
            expect(TimerService.setProposalTimer).toHaveBeenCalled()
            expect(result).toEqual(proposal)
        })
    })

    describe('deleteProposal', () => {
        it('должен удалять предложение если пользователь является автором', async () => {
            const proposal = {
                id: 'p1',
                storyId: 's1',
                authorId: 'u1',
            }
            const story = {
                id: 's1',
                currentPhase: Phase.PROPOSAL,
            }

            vi.mocked(prisma.chapterProposal.findUnique).mockResolvedValue(
                proposal as any
            )
            vi.mocked(prisma.story.findUnique).mockResolvedValue(story as any)
            vi.mocked(prisma.chapterProposal.delete).mockResolvedValue(
                {} as any
            )

            const result = await proposalService.deleteProposal(
                'p1',
                'u1',
                's1'
            )

            expect(prisma.chapterProposal.findUnique).toHaveBeenCalledWith({
                where: { id: 'p1', storyId: 's1' },
            })
            expect(prisma.story.findUnique).toHaveBeenCalledWith({
                where: { id: 's1' },
            })
            expect(prisma.chapterProposal.delete).toHaveBeenCalledWith({
                where: { id: 'p1', storyId: 's1' },
            })
            expect(result).toEqual({ success: true })
        })

        it('должен выбрасывать ошибку если пользователь не является автором', async () => {
            const proposal = {
                id: 'p1',
                storyId: 's1',
                authorId: 'u2', // другой пользователь
            }
            const story = {
                id: 's1',
                currentPhase: Phase.PROPOSAL,
            }

            vi.mocked(prisma.chapterProposal.findUnique).mockResolvedValue(
                proposal as any
            )
            vi.mocked(prisma.story.findUnique).mockResolvedValue(story as any)

            await expect(
                proposalService.deleteProposal('p1', 'u1', 's1')
            ).rejects.toThrow(ForbiddenError)
        })
    })

    describe('changeProposal', () => {
        it('должен изменять предложение если пользователь является автором', async () => {
            const proposal = {
                id: 'p1',
                storyId: 's1',
                authorId: 'u1',
                title: 'Old title',
                content: 'Old content',
            }
            const updatedProposal = {
                ...proposal,
                title: 'New title',
                content: 'New content',
            }
            const story = {
                id: 's1',
                currentPhase: Phase.PROPOSAL,
            }

            vi.mocked(prisma.chapterProposal.findUnique).mockResolvedValue(
                proposal as any
            )
            vi.mocked(prisma.story.findUnique).mockResolvedValue(story as any)
            vi.mocked(prisma.chapterProposal.update).mockResolvedValue(
                updatedProposal as any
            )

            const result = await proposalService.changeProposal(
                'p1',
                'u1',
                's1',
                'New title',
                'New content'
            )

            expect(prisma.chapterProposal.findUnique).toHaveBeenCalledWith({
                where: { id: 'p1', storyId: 's1' },
            })
            expect(prisma.chapterProposal.update).toHaveBeenCalledWith({
                where: { id: 'p1', storyId: 's1' },
                data: { title: 'New title', content: 'New content' },
            })
            expect(result).toEqual(updatedProposal)
        })
    })

    describe('selectWinnerProposal', () => {
        it('должен выбирать победившее предложение если пользователь админ', async () => {
            const proposal = {
                id: 'p1',
                storyId: 's1',
                authorId: 'u2',
                title: 'Winner title',
                content: 'Winner content',
            }
            const collaborator = {
                userId: 'u1',
                storyId: 's1',
                role: 'ADMIN',
            }

            vi.mocked(prisma.chapterProposal.findUnique).mockResolvedValue(
                proposal as any
            )
            vi.mocked(prisma.storyCollaborator.findFirst).mockResolvedValue(
                collaborator as any
            )

            await proposalService.selectWinnerProposal('p1', 'u1')

            expect(prisma.story.update).toHaveBeenCalledWith({
                where: { id: 's1' },
                data: { currentPhase: Phase.PROPOSAL, votingDeadline: null },
            })
            expect(prisma.chapter.updateMany).toHaveBeenCalledWith({
                where: { storyId: 's1', isLastChapter: true },
                data: { isLastChapter: false },
            })
            expect(chapterStoryService.createChapter).toHaveBeenCalledWith(
                's1',
                { title: 'Winner title', content: 'Winner content' },
                'u2'
            )
            expect(
                collaboratorService.addCollaboratorInStory
            ).toHaveBeenCalledWith('s1', 'u2')
            expect(prisma.chapterProposal.deleteMany).toHaveBeenCalledWith({
                where: { storyId: 's1' },
            })
        })
    })

    describe('voteProposal', () => {
        it('должен добавлять голос за предложение', async () => {
            const proposal = {
                id: 'p1',
                storyId: 's1',
            }
            const story = {
                id: 's1',
                currentPhase: Phase.VOTING,
            }

            vi.mocked(prisma.chapterProposal.findUnique).mockResolvedValue(
                proposal as any
            )
            vi.mocked(prisma.story.findUnique).mockResolvedValue(story as any)
            vi.mocked(prisma.vote.findFirst).mockResolvedValue(null)

            const result = await proposalService.voteProposal('p1', 'u1')

            expect(prisma.vote.create).toHaveBeenCalledWith({
                data: { chapterProposalId: 'p1', authorId: 'u1' },
            })
            expect(prisma.chapterProposal.update).toHaveBeenCalledWith({
                where: { id: 'p1' },
                data: { voteCount: { increment: 1 } },
            })
            expect(result).toEqual({ success: true })
        })

        it('должен выбросить ошибку, если пользователь уже голосовал', async () => {
            const proposal = {
                id: 'p1',
                storyId: 's1',
            }
            const vote = {
                id: 'v1',
                chapterProposalId: 'p1',
                authorId: 'u1',
            }
            const story = {
                id: 's1',
                currentPhase: Phase.VOTING,
            }

            vi.mocked(prisma.chapterProposal.findUnique).mockResolvedValue(
                proposal as any
            )
            vi.mocked(prisma.story.findUnique).mockResolvedValue(story as any)
            vi.mocked(prisma.vote.findFirst).mockResolvedValue(vote as any)

            await expect(
                proposalService.voteProposal('p1', 'u1')
            ).rejects.toThrow(ConflictError)
        })
    })

    describe('getProposalById', () => {
        it('должен возвращать предложение по id', async () => {
            const now = new Date()
            const proposal = {
                id: 'p1',
                title: 'Test proposal',
                content: 'Content',
                votes: [],
                createdAt: now,
                updatedAt: now,
            }

            vi.mocked(prisma.chapterProposal.findUnique).mockResolvedValue(
                proposal as any
            )

            const result = await proposalService.getProposalById('p1')

            expect(prisma.chapterProposal.findUnique).toHaveBeenCalledWith({
                where: { id: 'p1' },
                include: { votes: true },
            })
            expect(result).toEqual(proposal)
        })

        it('должен выбросить ошибку, если предложение не найдено', async () => {
            vi.mocked(prisma.chapterProposal.findUnique).mockResolvedValue(null)

            await expect(proposalService.getProposalById('p1')).rejects.toThrow(
                NotFoundError
            )
        })
    })

    describe('endVoting', () => {
        it('должен выбирать победителя с наибольшим количеством голосов', async () => {
            const proposals = [
                {
                    id: 'p1',
                    voteCount: 3,
                    title: 'Winner',
                    content: 'Content',
                    authorId: 'u1',
                    storyId: 's1',
                },
                {
                    id: 'p2',
                    voteCount: 1,
                    title: 'Loser',
                    content: 'Content',
                    authorId: 'u2',
                    storyId: 's1',
                },
            ]

            vi.mocked(prisma.chapterProposal.findMany).mockResolvedValue(
                proposals as any
            )

            await proposalService.endVoting('s1')

            expect(prisma.story.update).toHaveBeenCalledWith({
                where: { id: 's1' },
                data: { currentPhase: Phase.PROPOSAL, votingDeadline: null },
            })
            expect(prisma.chapter.updateMany).toHaveBeenCalledWith({
                where: { storyId: 's1', isLastChapter: true },
                data: { isLastChapter: false },
            })
            expect(chapterStoryService.createChapter).toHaveBeenCalledWith(
                's1',
                { title: 'Winner', content: 'Content' },
                'u1'
            )
            expect(
                collaboratorService.addCollaboratorInStory
            ).toHaveBeenCalledWith('s1', 'u1')
            expect(prisma.chapterProposal.deleteMany).toHaveBeenCalledWith({
                where: { storyId: 's1' },
            })
        })

        it('должен случайно выбирать победителя, если нет голосов', async () => {
            const proposals = [
                {
                    id: 'p1',
                    voteCount: 0,
                    title: 'First',
                    content: 'Content',
                    authorId: 'u1',
                    storyId: 's1',
                },
                {
                    id: 'p2',
                    voteCount: 0,
                    title: 'Second',
                    content: 'Content',
                    authorId: 'u2',
                    storyId: 's1',
                },
            ]

            vi.mocked(prisma.chapterProposal.findMany).mockResolvedValue(
                proposals as any
            )

            global.Math.random = vi.fn().mockReturnValue(0.1)

            await proposalService.endVoting('s1')

            expect(chapterStoryService.createChapter).toHaveBeenCalled()
            expect(
                collaboratorService.addCollaboratorInStory
            ).toHaveBeenCalled()
        })
    })
})
</file>

<file path="services/story-service/src/services/story.service.test.ts">
import { describe, it, expect, beforeEach, vi } from 'vitest'
import { storyService } from './story.service'
import { prisma } from '../prisma'
import { TimerService } from './time.service'
import { BadRequestError, ForbiddenError, NotFoundError } from '../utils/errors'

vi.mock('../prisma', () => ({
    prisma: {
        story: {
            count: vi.fn(),
            findMany: vi.fn(),
            findUnique: vi.fn(),
            create: vi.fn(),
            update: vi.fn(),
            delete: vi.fn(),
        },
    },
    Role: {
        ADMIN: 'ADMIN',
    },
}))

vi.mock('./time.service', () => ({
    TimerService: {
        setProposalTimer: vi.fn(),
        clearProposalTimer: vi.fn(),
        setVotingTimer: vi.fn(),
        clearVotingTimer: vi.fn(),
        clearAllTimers: vi.fn(),
    },
}))

vi.mock('./proposal.service', () => ({
    proposalService: {
        endProposals: vi.fn(),
        endVoting: vi.fn(),
    },
}))

describe('storyService', () => {
    beforeEach(() => {
        vi.resetAllMocks()
    })

    describe('getStoriesPaginated', () => {
        it('должен возвращать корректную пагинацию и вызывать prisma', async () => {
            const now = new Date()
            const fakeStories = [
                {
                    id: 's1',
                    createdAt: now,
                    updatedAt: now,
                    proposalDeadline: null,
                    votingDeadline: null,
                },
                {
                    id: 's2',
                    createdAt: now,
                    updatedAt: now,
                    proposalDeadline: null,
                    votingDeadline: null,
                },
            ]
            ;(prisma.story.count as any).mockResolvedValue(4)
            ;(prisma.story.findMany as any).mockResolvedValue(fakeStories)

            const result = await storyService.getStoriesPaginated(
                2,
                2,
                undefined
            )

            expect(prisma.story.count).toHaveBeenCalledWith({
                where: {
                    OR: [{ isPublic: true }],
                },
            })
            expect(prisma.story.findMany).toHaveBeenCalledWith({
                where: {
                    OR: [{ isPublic: true }],
                },
                orderBy: { updatedAt: 'desc' },
                skip: 2,
                take: 2,
                include: { storyCollaborators: true, genres: true },
            })
            expect(result).toEqual({
                items: fakeStories.map((item) => ({
                    ...item,
                    proposalDeadline: null,
                    votingDeadline: null,
                })),
                totalCount: 4,
                totalPages: Math.ceil(4 / 2),
                page: 2,
                pageSize: 2,
            })
        })

        it('должен учитывать параметр userId при фильтрации историй', async () => {
            const now = new Date()
            const fakeStories = [
                {
                    id: 's1',
                    createdAt: now,
                    updatedAt: now,
                    proposalDeadline: null,
                    votingDeadline: null,
                },
            ]
            vi.mocked(prisma.story.count).mockResolvedValue(1)
            ;(prisma.story.findMany as any).mockResolvedValue(fakeStories)

            await storyService.getStoriesPaginated(1, 10, 'user1')

            expect(prisma.story.count).toHaveBeenCalledWith({
                where: {
                    OR: [
                        { isPublic: true },
                        { storyCollaborators: { some: { userId: 'user1' } } },
                    ],
                },
            })
            expect(prisma.story.findMany).toHaveBeenCalledWith({
                where: {
                    OR: [
                        { isPublic: true },
                        { storyCollaborators: { some: { userId: 'user1' } } },
                    ],
                },
                orderBy: { updatedAt: 'desc' },
                skip: 0,
                take: 10,
                include: { storyCollaborators: true, genres: true },
            })
        })
    })

    describe('createStory', () => {
        it('должен создавать новую историю с правильными данными', async () => {
            const now = new Date()
            const storyInput = {
                title: 'Test Story',
                description: 'Test Description',
                coverImageUrl: 'http://example.com/image.jpg',
                isPublic: true,
                proposalTime: 60000,
                votingTime: 60000,
                initialChapter: {
                    title: 'Chapter 1',
                    content: 'Once upon a time...',
                },
                genres: ['genre1', 'genre2'],
            }

            const createdStory = {
                id: 'story1',
                title: 'Test Story',
                description: 'Test Description',
                coverImageUrl: 'http://example.com/image.jpg',
                isPublic: true,
                proposalTime: 60000,
                votingTime: 60000,
                authorId: 'user1',
                createdAt: now,
                updatedAt: now,
                proposalDeadline: null,
                votingDeadline: null,
                currentPhase: 'PROPOSAL',
                viewCount: 0,
                storyCollaborators: [
                    {
                        id: 'collab1',
                        userId: 'user1',
                        role: 'ADMIN',
                        storyId: 'story1',
                    },
                ],
                genres: [
                    { id: 'genre1', name: 'Fantasy' },
                    { id: 'genre2', name: 'Sci-Fi' },
                ],
                chapters: [],
            }

            ;(prisma.story.create as any).mockResolvedValue(createdStory)

            const result = await storyService.createStory(storyInput, 'user1')

            expect(prisma.story.create).toHaveBeenCalledWith({
                data: {
                    title: storyInput.title,
                    description: storyInput.description,
                    coverImageUrl: storyInput.coverImageUrl,
                    isPublic: storyInput.isPublic,
                    proposalTime: storyInput.proposalTime,
                    votingTime: storyInput.votingTime,
                    authorId: 'user1',
                    chapters: {
                        create: {
                            title: storyInput.initialChapter.title,
                            content: storyInput.initialChapter.content,
                            authorId: 'user1',
                            position: 1,
                            isLastChapter: true,
                        },
                    },
                    genres: {
                        connect: [{ id: 'genre1' }, { id: 'genre2' }],
                    },
                    storyCollaborators: {
                        create: {
                            userId: 'user1',
                            role: 'ADMIN',
                        },
                    },
                },
                include: {
                    storyCollaborators: true,
                    genres: true,
                },
            })

            expect(result).toEqual({
                ...createdStory,
                storyCollaborators: [
                    { id: 'collab1', userId: 'user1', role: 'ADMIN' },
                ],
            })
        })

        it('должен вызывать BadRequestError при неверных жанрах', async () => {
            const error = new Error('Prisma error')
            error.code = 'P2025'
            vi.mocked(prisma.story.create).mockRejectedValue(error)

            const storyInput = {
                title: 'Test Story',
                description: 'Test Description',
                coverImageUrl: 'http://example.com/image.jpg',
                isPublic: true,
                proposalTime: 60000,
                votingTime: 60000,
                initialChapter: {
                    title: 'Chapter 1',
                    content: 'Once upon a time...',
                },
                genres: ['nonexistent'],
            }

            await expect(
                storyService.createStory(storyInput, 'user1')
            ).rejects.toThrow(BadRequestError)
        })
    })

    describe('getStoryById', () => {
        it('должен возвращать историю и увеличивать счетчик просмотров', async () => {
            const now = new Date()
            const story = {
                id: 'story1',
                title: 'Test Story',
                description: 'Test Description',
                viewCount: 5,
                createdAt: now,
                updatedAt: now,
                storyCollaborators: [],
                genres: [],
            }

            const updatedStory = {
                ...story,
                viewCount: 6,
            }

            ;(prisma.story.findUnique as any).mockResolvedValue(story)
            ;(prisma.story.update as any).mockResolvedValue(updatedStory)

            const result = await storyService.getStoryById('story1')

            expect(prisma.story.findUnique).toHaveBeenCalledWith({
                where: { id: 'story1' },
                include: {
                    storyCollaborators: true,
                    genres: true,
                },
            })
            expect(prisma.story.update).toHaveBeenCalledWith({
                where: { id: 'story1' },
                data: { viewCount: 6 },
                include: {
                    storyCollaborators: true,
                    genres: true,
                },
            })
            expect(result).toEqual(updatedStory)
        })

        it('должен выбрасывать NotFoundError если история не найдена', async () => {
            vi.mocked(prisma.story.findUnique).mockResolvedValue(null)

            await expect(
                storyService.getStoryById('nonexistent')
            ).rejects.toThrow(NotFoundError)
        })
    })

    describe('getMyStoriesPaginated', () => {
        it('должен возвращать истории пользователя', async () => {
            const now = new Date()
            const fakeStories = [
                {
                    id: 's1',
                    createdAt: now,
                    updatedAt: now,
                    proposalDeadline: null,
                    votingDeadline: null,
                    storyCollaborators: [{ userId: 'user1' }],
                    genres: [],
                },
            ]
            vi.mocked(prisma.story.count).mockResolvedValue(1)
            ;(prisma.story.findMany as any).mockResolvedValue(fakeStories)

            const result = await storyService.getMyStoriesPaginated(
                'user1',
                1,
                10
            )

            expect(prisma.story.count).toHaveBeenCalledWith({
                where: {
                    storyCollaborators: {
                        some: {
                            userId: 'user1',
                        },
                    },
                },
            })
            expect(prisma.story.findMany).toHaveBeenCalledWith({
                where: {
                    storyCollaborators: {
                        some: {
                            userId: 'user1',
                        },
                    },
                },
                orderBy: { updatedAt: 'desc' },
                skip: 0,
                take: 10,
                include: { storyCollaborators: true, genres: true },
            })
            expect(result).toEqual({
                items: fakeStories,
                totalCount: 1,
                totalPages: 1,
                page: 1,
                pageSize: 10,
            })
        })
    })

    describe('updateStory', () => {
        it('должен обновлять историю если пользователь имеет роль ADMIN', async () => {
            const now = new Date()
            const story = {
                id: 'story1',
                title: 'Old Title',
                description: 'Old Description',
                currentPhase: 'PROPOSAL',
                proposalTime: 60000,
                votingTime: 60000,
                proposalDeadline: null,
                votingDeadline: null,
                createdAt: now,
                updatedAt: now,
                storyCollaborators: [{ userId: 'user1', role: 'ADMIN' }],
                genres: [],
            }

            const updatedStory = {
                ...story,
                title: 'New Title',
                description: 'New Description',
            }

            ;(prisma.story.findUnique as any).mockResolvedValue(story)
            ;(prisma.story.update as any).mockResolvedValue(updatedStory)

            const result = await storyService.updateStory(
                'story1',
                { title: 'New Title', description: 'New Description' },
                'user1'
            )

            expect(prisma.story.findUnique).toHaveBeenCalledWith({
                where: { id: 'story1' },
                include: {
                    storyCollaborators: true,
                    genres: true,
                },
            })
            expect(prisma.story.update).toHaveBeenCalledWith({
                where: { id: 'story1' },
                data: {
                    title: 'New Title',
                    description: 'New Description',
                    genres: undefined,
                },
                include: {
                    storyCollaborators: true,
                    genres: true,
                },
            })
            expect(result).toEqual(updatedStory)
        })

        it('должен пересчитывать время proposal если proposalTime был изменен в фазе PROPOSAL', async () => {
            const now = new Date()
            const proposalDeadline = new Date(now.getTime() + 30000) // 30 секунд в будущем

            const story = {
                id: 'story1',
                proposalTime: 60000, // 60 сек
                currentPhase: 'PROPOSAL',
                proposalDeadline: proposalDeadline,
                storyCollaborators: [{ userId: 'user1', role: 'ADMIN' }],
                genres: [],
            }

            const updatedStory = {
                ...story,
                proposalTime: 120000, // 120 сек
            }

            ;(prisma.story.findUnique as any).mockResolvedValue(story)
            ;(prisma.story.update as any).mockResolvedValue(updatedStory)

            // Зафиксируем текущее время для предсказуемости
            const fixedNow = new Date('2023-01-01T12:00:00Z')
            vi.spyOn(global, 'Date').mockImplementation(() => fixedNow)

            await storyService.updateStory(
                'story1',
                { proposalTime: 120000 },
                'user1'
            )

            expect(TimerService.clearProposalTimer).toHaveBeenCalledWith(
                'story1'
            )
            expect(prisma.story.update).toHaveBeenCalled()
            expect(TimerService.setProposalTimer).toHaveBeenCalledWith(
                'story1',
                expect.any(Number),
                expect.any(Function)
            )
        })

        it('должен выбрасывать ForbiddenError если пользователь не имеет роль ADMIN', async () => {
            const story = {
                id: 'story1',
                storyCollaborators: [{ userId: 'user1', role: 'EDITOR' }],
                genres: [],
            }

            ;(prisma.story.findUnique as any).mockResolvedValue(story)

            await expect(
                storyService.updateStory(
                    'story1',
                    { title: 'New Title' },
                    'user1'
                )
            ).rejects.toThrow(ForbiddenError)
        })

        it('должен выбрасывать NotFoundError если история не найдена', async () => {
            vi.mocked(prisma.story.findUnique).mockResolvedValue(null)

            await expect(
                storyService.updateStory(
                    'nonexistent',
                    { title: 'New Title' },
                    'user1'
                )
            ).rejects.toThrow(NotFoundError)
        })
    })

    describe('deleteStory', () => {
        it('должен удалять историю если пользователь имеет роль ADMIN', async () => {
            const story = {
                id: 'story1',
                storyCollaborators: [{ userId: 'user1', role: 'ADMIN' }],
            }

            ;(prisma.story.findUnique as any).mockResolvedValue(story)
            ;(prisma.story.delete as any).mockResolvedValue({} as any)

            const result = await storyService.deleteStory('story1', 'user1')

            expect(prisma.story.findUnique).toHaveBeenCalledWith({
                where: { id: 'story1' },
                include: {
                    storyCollaborators: true,
                },
            })
            expect(prisma.story.delete).toHaveBeenCalledWith({
                where: { id: 'story1' },
            })
            expect(TimerService.clearAllTimers).toHaveBeenCalledWith('story1')
            expect(result).toEqual({ success: true })
        })

        it('должен выбрасывать ForbiddenError если пользователь не имеет роль ADMIN', async () => {
            const story = {
                id: 'story1',
                storyCollaborators: [{ userId: 'user1', role: 'EDITOR' }],
            }

            ;(prisma.story.findUnique as any).mockResolvedValue(story)

            await expect(
                storyService.deleteStory('story1', 'user1')
            ).rejects.toThrow(ForbiddenError)
        })

        it('должен выбрасывать NotFoundError если история не найдена', async () => {
            vi.mocked(prisma.story.findUnique).mockResolvedValue(null)

            await expect(
                storyService.deleteStory('nonexistent', 'user1')
            ).rejects.toThrow(NotFoundError)
        })
    })
})
</file>

<file path="services/story-service/src/services/time.service.test.ts">
import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest'
import { TimerService } from './time.service'

describe('TimerService', () => {
    beforeEach(() => {
        vi.useFakeTimers()
        ;(TimerService as any).timers = new Map()
    })

    afterEach(() => {
        vi.restoreAllMocks()
    })

    describe('setProposalTimer', () => {
        it('должен устанавливать таймер предложений', () => {
            const callback = vi.fn()

            TimerService.setProposalTimer('story1', 1000, callback)

            expect((TimerService as any).timers.has('story1')).toBe(true)
            expect(
                (TimerService as any).timers.get('story1').proposalTimer
            ).toBeDefined()

            expect(callback).not.toHaveBeenCalled()

            vi.advanceTimersByTime(1000)

            expect(callback).toHaveBeenCalledTimes(1)
        })

        it('должен очищать предыдущий таймер при установке нового', () => {
            const callback1 = vi.fn()
            const callback2 = vi.fn()
            const clearTimeoutSpy = vi.spyOn(global, 'clearTimeout')

            TimerService.setProposalTimer('story1', 1000, callback1)
            TimerService.setProposalTimer('story1', 2000, callback2)

            expect(clearTimeoutSpy).toHaveBeenCalledTimes(1)

            vi.advanceTimersByTime(1000)

            expect(callback1).not.toHaveBeenCalled()

            vi.advanceTimersByTime(1000)

            expect(callback2).toHaveBeenCalledTimes(1)
        })
    })

    describe('setVotingTimer', () => {
        it('должен устанавливать таймер голосования', () => {
            const callback = vi.fn()

            TimerService.setVotingTimer('story1', 1500, callback)

            expect((TimerService as any).timers.has('story1')).toBe(true)
            expect(
                (TimerService as any).timers.get('story1').votingTimer
            ).toBeDefined()

            expect(callback).not.toHaveBeenCalled()

            vi.advanceTimersByTime(1500)

            expect(callback).toHaveBeenCalledTimes(1)
        })

        it('должен очищать предыдущий таймер при установке нового', () => {
            const callback1 = vi.fn()
            const callback2 = vi.fn()
            const clearTimeoutSpy = vi.spyOn(global, 'clearTimeout')

            TimerService.setVotingTimer('story1', 1000, callback1)
            TimerService.setVotingTimer('story1', 2000, callback2)

            expect(clearTimeoutSpy).toHaveBeenCalledTimes(1)

            vi.advanceTimersByTime(1000)

            expect(callback1).not.toHaveBeenCalled()

            vi.advanceTimersByTime(1000)

            expect(callback2).toHaveBeenCalledTimes(1)
        })
    })

    describe('clearProposalTimer', () => {
        it('должен очищать таймер предложений', () => {
            const callback = vi.fn()
            const clearTimeoutSpy = vi.spyOn(global, 'clearTimeout')

            TimerService.setProposalTimer('story1', 1000, callback)
            TimerService.clearProposalTimer('story1')

            expect(clearTimeoutSpy).toHaveBeenCalledTimes(1)

            vi.advanceTimersByTime(1000)

            expect(callback).not.toHaveBeenCalled()

            expect(
                (TimerService as any).timers.get('story1').proposalTimer
            ).toBeUndefined()
        })

        it('не должен вызывать ошибку если таймер не существует', () => {
            expect(() => {
                TimerService.clearProposalTimer('nonexistentStory')
            }).not.toThrow()
        })
    })

    describe('clearVotingTimer', () => {
        it('должен очищать таймер голосования', () => {
            const callback = vi.fn()
            const clearTimeoutSpy = vi.spyOn(global, 'clearTimeout')

            TimerService.setVotingTimer('story1', 1000, callback)
            TimerService.clearVotingTimer('story1')

            expect(clearTimeoutSpy).toHaveBeenCalledTimes(1)

            vi.advanceTimersByTime(1000)

            expect(callback).not.toHaveBeenCalled()

            expect(
                (TimerService as any).timers.get('story1').votingTimer
            ).toBeUndefined()
        })

        it('не должен вызывать ошибку если таймер не существует', () => {
            expect(() => {
                TimerService.clearVotingTimer('nonexistentStory')
            }).not.toThrow()
        })
    })

    describe('clearAllTimers', () => {
        it('должен очищать все таймеры истории', () => {
            const proposalCallback = vi.fn()
            const votingCallback = vi.fn()
            const clearTimeoutSpy = vi.spyOn(global, 'clearTimeout')

            TimerService.setProposalTimer('story1', 1000, proposalCallback)
            TimerService.setVotingTimer('story1', 1500, votingCallback)

            TimerService.clearAllTimers('story1')

            expect(clearTimeoutSpy).toHaveBeenCalledTimes(2)

            vi.advanceTimersByTime(1500)

            expect(proposalCallback).not.toHaveBeenCalled()
            expect(votingCallback).not.toHaveBeenCalled()

            expect((TimerService as any).timers.has('story1')).toBe(false)
        })

        it('не должен вызывать ошибку если таймеры не существуют', () => {
            expect(() => {
                TimerService.clearAllTimers('nonexistentStory')
            }).not.toThrow()
        })
    })

    it('должен поддерживать независимые таймеры для разных историй', () => {
        const callback1 = vi.fn()
        const callback2 = vi.fn()

        TimerService.setProposalTimer('story1', 1000, callback1)
        TimerService.setProposalTimer('story2', 2000, callback2)

        expect((TimerService as any).timers.has('story1')).toBe(true)
        expect((TimerService as any).timers.has('story2')).toBe(true)

        vi.advanceTimersByTime(1000)

        expect(callback1).toHaveBeenCalledTimes(1)
        expect(callback2).not.toHaveBeenCalled()

        vi.advanceTimersByTime(1000)

        expect(callback2).toHaveBeenCalledTimes(1)
    })

    it('должен корректно работать со смешанными таймерами', () => {
        const proposalCallback = vi.fn()
        const votingCallback = vi.fn()

        TimerService.setProposalTimer('story1', 1000, proposalCallback)
        TimerService.setVotingTimer('story1', 2000, votingCallback)

        vi.advanceTimersByTime(1000)

        expect(proposalCallback).toHaveBeenCalledTimes(1)
        expect(votingCallback).not.toHaveBeenCalled()

        vi.advanceTimersByTime(1000)

        expect(votingCallback).toHaveBeenCalledTimes(1)
    })
})
</file>

<file path="services/story-service/src/services/time.service.ts">
interface StoryTimers {
    proposalTimer?: NodeJS.Timeout
    votingTimer?: NodeJS.Timeout
}

export class TimerService {
    private static timers: Map<string, StoryTimers> = new Map()

    static setProposalTimer(
        storyId: string,
        duration: number,
        callback: () => void
    ): void {
        this.clearProposalTimer(storyId)
        const timer = setTimeout(callback, duration)

        if (!this.timers.has(storyId)) {
            this.timers.set(storyId, {})
        }

        this.timers.get(storyId)!.proposalTimer = timer
        console.log(
            `Установлен таймер предложений для истории ${storyId} на ${duration}ms`
        )
    }

    static setVotingTimer(
        storyId: string,
        duration: number,
        callback: () => void
    ): void {
        this.clearVotingTimer(storyId)
        const timer = setTimeout(callback, duration)

        if (!this.timers.has(storyId)) {
            this.timers.set(storyId, {})
        }

        this.timers.get(storyId)!.votingTimer = timer
        console.log(
            `Установлен таймер голосования для истории ${storyId} на ${duration}ms`
        )
    }

    static clearProposalTimer(storyId: string): void {
        const storyTimers = this.timers.get(storyId)
        if (storyTimers?.proposalTimer) {
            clearTimeout(storyTimers.proposalTimer)
            console.log(`Очищен таймер предложений для истории ${storyId}`)
            storyTimers.proposalTimer = undefined
        }
    }

    static clearVotingTimer(storyId: string): void {
        const storyTimers = this.timers.get(storyId)
        if (storyTimers?.votingTimer) {
            clearTimeout(storyTimers.votingTimer)
            console.log(`Очищен таймер голосования для истории ${storyId}`)
            storyTimers.votingTimer = undefined
        }
    }

    static clearAllTimers(storyId: string): void {
        this.clearProposalTimer(storyId)
        this.clearVotingTimer(storyId)
        this.timers.delete(storyId)
        console.log(`Очищены все таймеры для истории ${storyId}`)
    }
}
</file>

<file path="services/story-service/src/startup.ts">
import { prisma, Phase } from './prisma'
import { proposalService } from './services/proposal.service'
import { TimerService } from './services/time.service'

export async function initializeTimers() {
    console.log('Инициализация таймеров для активных историй...')

    const storiesWithDeadlines = await prisma.story.findMany({
        where: {
            OR: [
                { proposalDeadline: { not: null } },
                { votingDeadline: { not: null } },
            ],
        },
    })

    const now = new Date().getTime()

    for (const story of storiesWithDeadlines) {
        if (story.currentPhase === Phase.PROPOSAL && story.proposalDeadline) {
            const deadline = story.proposalDeadline.getTime()
            const remainingTime = Math.max(deadline - now, 0)

            if (remainingTime > 0) {
                console.log(
                    `Инициализация таймера предложений для истории ${story.id}, осталось ${remainingTime}ms`
                )
                TimerService.setProposalTimer(story.id, remainingTime, () =>
                    proposalService.endProposals(story.id)
                )
            } else {
                console.log(
                    `Пропущен дедлайн предложений для истории ${story.id}, завершаем фазу немедленно`
                )
                proposalService.endProposals(story.id).catch((err) => {
                    console.error(
                        `Ошибка при завершении фазы предложений для истории ${story.id}:`,
                        err
                    )
                })
            }
        }

        if (story.currentPhase === Phase.VOTING && story.votingDeadline) {
            const deadline = story.votingDeadline.getTime()
            const remainingTime = Math.max(deadline - now, 0)

            if (remainingTime > 0) {
                console.log(
                    `Инициализация таймера голосования для истории ${story.id}, осталось ${remainingTime}ms`
                )
                TimerService.setVotingTimer(story.id, remainingTime, () =>
                    proposalService.endVoting(story.id)
                )
            } else {
                console.log(
                    `Пропущен дедлайн голосования для истории ${story.id}, завершаем фазу немедленно`
                )
                proposalService.endVoting(story.id).catch((err) => {
                    console.error(
                        `Ошибка при завершении фазы голосования для истории ${story.id}:`,
                        err
                    )
                })
            }
        }
    }

    console.log(`Инициализировано ${storiesWithDeadlines.length} таймеров`)
}
</file>

<file path="services/story-service/src/utils/errors.ts">
export class AppError extends Error {
    statusCode: number
    isOperational: boolean

    constructor(message: string, statusCode: number) {
        super(message)
        this.statusCode = statusCode
        this.isOperational = true

        Error.captureStackTrace(this, this.constructor)
    }
}

export class BadRequestError extends AppError {
    constructor(message: string = 'Некорректные данные запроса') {
        super(message, 400)
    }
}

export class UnauthorizedError extends AppError {
    constructor(message: string = 'Необходима авторизация') {
        super(message, 401)
    }
}

export class ForbiddenError extends AppError {
    constructor(message: string = 'Доступ запрещен') {
        super(message, 403)
    }
}

export class NotFoundError extends AppError {
    constructor(message: string = 'Ресурс не найден') {
        super(message, 404)
    }
}

export class ConflictError extends AppError {
    constructor(message: string = 'Конфликт данных') {
        super(message, 409)
    }
}

export class InternalServerError extends AppError {
    constructor(message: string = 'Внутренняя ошибка сервера') {
        super(message, 500)
    }
}
</file>

<file path="services/story-service/tests/integration/chapter-proposal.api.spec.ts">
import { test, expect } from '@playwright/test'

const testStory = {
    title: 'История для теста глав',
    description:
        'Эта история используется для тестирования API глав и предложений',
    initialChapter: {
        title: 'Начальная глава',
        content: 'Содержание начальной главы для тестов.',
    },
}

test.describe('Chapter and Proposal API', () => {
    let storyId: string
    let chapterId: string
    const userId: string = '00000000-0000-0000-0000-000000000001'
    let genreId: string
    let proposalId: string

    test.beforeAll(async ({ request }) => {
        const genreResponse = await request.get('genres/')
        expect(genreResponse.status()).toBe(200)
        const genreBody = await genreResponse.json()
        expect(genreBody.genres.length).toBeGreaterThan(0)
        genreId = genreBody.genres[0].id

        // Создаем тестовую историю
        const storyResponse = await request.post('/', {
            headers: {
                'Content-Type': 'application/json',
                'x-user-object': JSON.stringify({ userId }),
            },
            data: {
                ...testStory,
                genres: [genreId],
            },
        })

        if (storyResponse.ok()) {
            const story = await storyResponse.json()
            storyId = story.id
            console.log(`Создана тестовая история с ID: ${storyId}`)
        } else {
            console.error(
                'Не удалось создать тестовую историю для тестирования глав'
            )
            test.skip(true, 'Не удалось создать тестовую историю')
        }
    })

    test('GET /:storyId/chapters должен возвращать главы истории', async ({
        request,
    }) => {
        test.skip(!storyId, 'Требуется ID истории из setup')

        const response = await request.get(
            `/${storyId}/chapters?page=1&pageSize=10`
        )

        expect(response.status()).toBe(200)
        const body = await response.json()

        expect(body).toHaveProperty('items')
        expect(body).toHaveProperty('totalCount')
        expect(body).toHaveProperty('totalPages')
        expect(body).toHaveProperty('page')
        expect(body).toHaveProperty('pageSize')
        expect(Array.isArray(body.items)).toBe(true)
        expect(body.items.length).toBeGreaterThan(0)

        if (body.items.length > 0) {
            chapterId = body.items[0].id
            console.log(`Найдена глава с ID: ${chapterId}`)
        }
    })

    const proposalTestData = [
        {
            title: 'Тестовое предложение 1',
            content: 'Содержание первого тестового предложения для API-теста.',
            testName: 'Первое предложение',
        },
        {
            title: 'Тестовое предложение 2',
            content: 'Содержание второго тестового предложения для API-теста.',
            testName: 'Второе предложение',
        },
        {
            title: 'Тестовое предложение 3',
            content: 'Содержание третьего тестового предложения для API-теста.',
            testName: 'Третье предложение',
        },
        {
            title: 'Тестовое предложение 4',
            content:
                'Содержание четвертого тестового предложения для API-теста.',
            testName: 'Четвертое предложение',
        },
        {
            title: 'Тестовое предложение 5',
            content: 'Содержание пятого тестового предложения для API-теста.',
            testName: 'Пятое предложение',
        },
    ]

    for (const proposalData of proposalTestData) {
        test(`POST /:storyId/chapters/:chapterId/proposals должен создавать предложение к главе (${proposalData.testName})`, async ({
            request,
        }) => {
            test.skip(
                !chapterId || !storyId,
                'Требуется ID истории и главы из предыдущего теста'
            )

            const response = await request.post(
                `/${storyId}/chapters/${chapterId}/proposals`,
                {
                    headers: {
                        'Content-Type': 'application/json',
                        'x-user-object': JSON.stringify({ userId }),
                    },
                    data: proposalData,
                }
            )

            expect(response.status()).toBe(201)
            const proposal = await response.json()

            expect(proposal).toHaveProperty('id')
            expect(proposal.title).toBe(proposalData.title)
            expect(proposal.content).toBe(proposalData.content)
            expect(proposal.storyId).toBe(storyId)
            expect(proposal.parentChapterId).toBe(chapterId)
            expect(proposal.authorId).toBe(userId)

            proposalId = proposal.id
        })
    }

    test('GET /:storyId/chapters/:chapterId/proposals должен возвращать предложения к главе', async ({
        request,
    }) => {
        test.skip(
            !chapterId || !storyId,
            'Требуется ID истории и главы из предыдущих тестов'
        )

        const response = await request.get(
            `/${storyId}/chapters/${chapterId}/proposals?page=1&pageSize=10`
        )

        expect(response.status()).toBe(200)
        const body = await response.json()

        expect(body).toHaveProperty('items')
        expect(body).toHaveProperty('totalCount')
        expect(body).toHaveProperty('totalPages')
        expect(body).toHaveProperty('page')
        expect(body).toHaveProperty('pageSize')
        expect(Array.isArray(body.items)).toBe(true)
    })

    test('POST /proposals/:proposalId/vote должен регистрировать голос', async ({
        request,
    }) => {
        test.skip(
            !proposalId,
            'Требуется ID возможной главы из предыдущих тестов'
        )

        const response = await request.post(`/proposals/${proposalId}/vote`, {
            headers: {
                'x-user-object': JSON.stringify({ userId }),
            },
        })

        if (response.status() === 200) {
            const result = await response.json()
            expect(result).toHaveProperty('success')
        } else {
            console.log(`Голосование не доступно, статус: ${response.status()}`)
        }
    })

    test('POST /proposals/:proposalId/vote должен возвращать 401 без аутентификации', async ({
        request,
    }) => {
        test.skip(
            !proposalId,
            'Требуется ID возможной главы из предыдущих тестов'
        )

        const proposalData = {
            title: 'Предложение без авторизации',
            content: 'Это предложение не должно быть создано.',
        }

        const response = await request.post(`/proposals/${proposalId}/vote`, {
            headers: {
                'Content-Type': 'application/json',
            },
            data: proposalData,
        })

        expect(response.status()).toBe(401)
    })

    test('POST /proposals/:proposalId/vote должен возвращать 400, если пользователь уже голосовал', async ({
        request,
    }) => {
        test.skip(
            !proposalId,
            'Требуется ID возможной главы из предыдущих тестов'
        )

        const response = await request.post(`/proposals/${proposalId}/vote`, {
            headers: {
                'x-user-object': JSON.stringify({ userId }),
            },
        })

        expect(response.status()).toBe(400)
    })

    test.afterAll(async ({ request }) => {
        if (storyId) {
            const response = await request.delete(`/${storyId}`, {
                headers: {
                    'x-user-object': JSON.stringify({ userId }),
                },
            })

            expect(response.status()).toBe(204)
        }
    })
})
</file>

<file path="services/story-service/tests/integration/story-lifecycle.api.spec.ts">
import { test, expect } from '@playwright/test'

const testStory = {
    title: 'Тестирование жизненного цикла истории',
    description: 'История для тестирования фаз PROPOSAL и VOTING',
    proposalTime: 3000,
    votingTime: 3000,
    initialChapter: {
        title: 'Начальная глава',
        content: 'Содержание начальной главы для тестов жизненного цикла.',
    },
}

const waitForPhaseChange = async (
    request,
    storyId,
    expectedPhase,
    maxAttempts = 10
) => {
    for (let i = 0; i < maxAttempts; i++) {
        await new Promise((resolve) => setTimeout(resolve, 1000))

        const storyResponse = await request.get(`/${storyId}`)
        if (storyResponse.status() === 200) {
            const story = await storyResponse.json()
            if (story.currentPhase === expectedPhase) {
                return story
            }
        }
    }
    throw new Error(
        `Фаза не изменилась на ${expectedPhase} после ${maxAttempts} попыток`
    )
}

test.describe('Жизненный цикл истории: PROPOSAL -> VOTING -> Новая глава', () => {
    let storyId: string
    let chapterId: string
    const userId: string = '00000000-0000-0000-0000-000000000001'
    const secondUserId: string = '00000000-0000-0000-0000-000000000002'
    let genreId: string
    let firstProposalId: string

    test('1. Создание новой истории', async ({ request }) => {
        const genreResponse = await request.get('genres/')
        expect(genreResponse.status()).toBe(200)
        const genreBody = await genreResponse.json()
        expect(genreBody.genres.length).toBeGreaterThan(0)
        genreId = genreBody.genres[0].id

        const storyResponse = await request.post('/', {
            headers: {
                'Content-Type': 'application/json',
                'x-user-object': JSON.stringify({ userId }),
            },
            data: {
                ...testStory,
                genres: [genreId],
            },
        })

        expect(storyResponse.status()).toBe(201)
        const story = await storyResponse.json()
        storyId = story.id
        console.log(`Создана тестовая история с ID: ${storyId}`)

        expect(story.currentPhase).toBe('PROPOSAL')
        expect(story.proposalDeadline).toBeNull()
    })

    test('2. Получение ID последней главы истории', async ({ request }) => {
        test.skip(!storyId, 'Требуется ID истории из предыдущего шага')

        const response = await request.get(`/${storyId}/chapters`)
        expect(response.status()).toBe(200)
        const body = await response.json()

        expect(body).toHaveProperty('items')
        expect(body.items.length).toBeGreaterThan(0)
        expect(body.items[0].isLastChapter).toBe(true)

        chapterId = body.items[0].id
        console.log(`Получена последняя глава с ID: ${chapterId}`)
    })

    test('3. Создание первого предложения', async ({ request }) => {
        test.skip(!storyId || !chapterId, 'Требуется ID истории и главы')

        const proposalData = {
            title: 'Первое предложение',
            content:
                'Содержание первого предложения для проверки цикла истории',
        }

        const response = await request.post(
            `/${storyId}/chapters/${chapterId}/proposals`,
            {
                headers: {
                    'Content-Type': 'application/json',
                    'x-user-object': JSON.stringify({ userId: secondUserId }),
                },
                data: proposalData,
            }
        )

        expect(response.status()).toBe(201)
        const proposal = await response.json()
        firstProposalId = proposal.id

        const storyResponse = await request.get(`/${storyId}`)
        expect(storyResponse.status()).toBe(200)
        const story = await storyResponse.json()
        expect(story.currentPhase).toBe('PROPOSAL')
        expect(story.proposalDeadline).toBeNull()
    })

    test('4. Создание второго предложения и активация таймера PROPOSAL', async ({
        request,
    }) => {
        test.skip(!storyId || !chapterId, 'Требуется ID истории и главы')

        const proposalData = {
            title: 'Второе предложение',
            content:
                'Содержание второго предложения для проверки цикла истории',
        }

        const response = await request.post(
            `/${storyId}/chapters/${chapterId}/proposals`,
            {
                headers: {
                    'Content-Type': 'application/json',
                    'x-user-object': JSON.stringify({ userId }),
                },
                data: proposalData,
            }
        )

        expect(response.status()).toBe(201)

        const storyResponse = await request.get(`/${storyId}`)
        expect(storyResponse.status()).toBe(200)
        const story = await storyResponse.json()
        expect(story.currentPhase).toBe('PROPOSAL')
        expect(story.proposalDeadline).not.toBeNull()

        console.log(
            `Начало фазы PROPOSAL с дедлайном: ${story.proposalDeadline}`
        )
    })

    test('5. Попытка голосования в фазе PROPOSAL', async ({ request }) => {
        test.skip(!firstProposalId, 'Требуется ID предложения')

        const response = await request.post(
            `/proposals/${firstProposalId}/vote`,
            {
                headers: {
                    'x-user-object': JSON.stringify({ userId }),
                },
            }
        )

        expect(response.status()).toBe(400)
        const error = await response.json()
        expect(error.message).toContain('не фаза голосования')
    })

    test('6. Ожидание окончания фазы PROPOSAL и переход в фазу VOTING', async ({
        request,
    }) => {
        test.skip(!storyId, 'Требуется ID истории')

        console.log('Ожидание завершения фазы PROPOSAL...')
        const story = await waitForPhaseChange(request, storyId, 'VOTING')

        expect(story.currentPhase).toBe('VOTING')
        expect(story.votingDeadline).not.toBeNull()
        expect(story.proposalDeadline).toBeNull()

        console.log(`Начало фазы VOTING с дедлайном: ${story.votingDeadline}`)
    })

    test('7. Голосование в фазе VOTING', async ({ request }) => {
        test.skip(!firstProposalId, 'Требуется ID предложения')

        const response = await request.post(
            `/proposals/${firstProposalId}/vote`,
            {
                headers: {
                    'x-user-object': JSON.stringify({ userId }),
                },
            }
        )

        expect(response.status()).toBe(200)
        const result = await response.json()
        expect(result).toHaveProperty('success', true)
    })

    test('8. Ожидание окончания фазы VOTING и выбор победителя', async ({
        request,
    }) => {
        test.skip(!storyId, 'Требуется ID истории')

        console.log('Ожидание завершения фазы VOTING...')
        const story = await waitForPhaseChange(request, storyId, 'PROPOSAL')

        expect(story.currentPhase).toBe('PROPOSAL')
        expect(story.votingDeadline).toBeNull()
    })

    test('9. Проверка создания новой главы после выбора победителя', async ({
        request,
    }) => {
        test.skip(!storyId, 'Требуется ID истории')

        const response = await request.get(`/${storyId}/chapters`)
        const responseStory = await request.get(`/${storyId}`)
        expect(response.status()).toBe(200)
        expect(responseStory.status()).toBe(200)
        const body = await response.json()
        const story = await responseStory.json()

        expect(story.storyCollaborators).toHaveLength(2)
        expect(story.storyCollaborators[0].userId).toBe(userId)
        expect(story.storyCollaborators[0].role).toBe('ADMIN')
        expect(story.storyCollaborators[1].userId).toBe(secondUserId)
        expect(story.storyCollaborators[1].role).toBe('USER')

        expect(body).toHaveProperty('items')
        expect(body.items.length).toBeGreaterThan(1)

        const lastChapter = body.items.find(
            (chapter) => chapter.isLastChapter === true
        )
        expect(lastChapter).toBeDefined()
        expect(lastChapter.title).toContain('Первое предложение')
    })

    test.afterAll(async ({ request }) => {
        if (storyId) {
            const response = await request.delete(`/${storyId}`, {
                headers: {
                    'x-user-object': JSON.stringify({ userId }),
                },
            })

            expect(response.status()).toBe(204)
        }
    })
})
</file>

<file path="services/story-service/tests/integration/story-serivce.api.spec.ts">
import { test, expect } from '@playwright/test'

const testStory = {
    title: 'Интеграционный тест истории',
    description:
        'Это история создана автоматическим интеграционным тестом Playwright',
    initialChapter: {
        title: 'Первая глава',
        content: 'Содержание первой главы, созданной тестом.',
    },
}

test.describe('Story Service API', () => {
    let createdStoryId: string
    const userId: string = '00000000-0000-0000-0000-000000000001'
    let genreId: string

    test('GET /genres/ должен возвращать список жанров', async ({
        request,
    }) => {
        const response = await request.get('/genres/')

        expect(response.status()).toBe(200)
        const body = await response.json()

        expect(body).toHaveProperty('count')
        expect(body).toHaveProperty('genres')
        expect(Array.isArray(body.genres)).toBe(true)
        expect(body.genres.length).toBeGreaterThan(0)
        expect(body.genres[0]).toHaveProperty('id')
        expect(body.genres[0]).toHaveProperty('name')

        genreId = body.genres[0].id
    })

    test('GET / должен возвращать пагинированный список историй', async ({
        request,
    }) => {
        const response = await request.get('/?page=1&pageSize=10')

        expect(response.status()).toBe(200)
        const body = await response.json()

        expect(body).toHaveProperty('items')
        expect(body).toHaveProperty('totalCount')
        expect(body).toHaveProperty('totalPages')
        expect(body).toHaveProperty('page')
        expect(body).toHaveProperty('pageSize')
        expect(Array.isArray(body.items)).toBe(true)
    })

    test('POST / должен создавать новую историю, если пользователь аутентифицирован', async ({
        request,
    }) => {
        const response = await request.post('/', {
            headers: {
                'x-user-object': JSON.stringify({ userId }),
                'Content-Type': 'application/json',
            },
            data: {
                ...testStory,
                genres: [genreId],
            },
        })

        expect(response.status()).toBe(201)
        const story = await response.json()

        expect(story).toHaveProperty('id')
        expect(story.title).toBe(testStory.title)
        expect(story.description).toBe(testStory.description)
        expect(story.authorId).toBe(userId)

        createdStoryId = story.id
    })

    test('GET /:id должен возвращать историю по ID', async ({ request }) => {
        test.skip(
            !createdStoryId,
            'Требуется ID, созданный в тесте создания истории'
        )

        const response = await request.get(`/${createdStoryId}`)

        expect(response.status()).toBe(200)
        const story = await response.json()

        expect(story).toHaveProperty('id')
        expect(story.id).toBe(createdStoryId)
        expect(story.title).toBe(testStory.title)
        expect(story.description).toBe(testStory.description)
    })

    test('POST / должен возвращать 401 без заголовка аутентификации', async ({
        request,
    }) => {
        const response = await request.post('/', {
            headers: {
                'Content-Type': 'application/json',
            },
            data: testStory,
        })

        expect(response.status()).toBe(401)
    })

    test('POST / должен возвращать 400 при некорректных данных', async ({
        request,
    }) => {
        const invalidStory = {
            title: 'Т', // менее 3 символов
            description: 'Короткое', // менее 10 символов
            genres: [], // пустой массив
            isPublic: true,
            initialChapter: {
                title: '', // пустая строка
                content: 'Содержание',
            },
        }

        const response = await request.post('/', {
            headers: {
                'Content-Type': 'application/json',
                'x-user-object': JSON.stringify({ userId }),
            },
            data: invalidStory,
        })

        expect(response.status()).toBe(400)
    })

    test.afterAll(async ({ request }) => {
        if (createdStoryId) {
            const response = await request.delete(`/${createdStoryId}`, {
                headers: {
                    'x-user-object': JSON.stringify({ userId }),
                },
            })
            expect(response.status()).toBe(204)
        }
    })
})
</file>

<file path="services/user-profile-service/.gitignore">
.env
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 Ilya

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="services/api-gateway/src/plugins/index.ts">
import sensible from './sensible'
import proxy from './proxy'
import swagger from './swagger'

export default {
    sensible,
    proxy,
    swagger,
}
</file>

<file path="services/api-gateway/src/plugins/swagger.ts">
import fastifyPlugin from 'fastify-plugin'
import { FastifyInstance } from 'fastify'
import fastifySwagger from '@fastify/swagger'
import fastifySwaggerUi from '@fastify/swagger-ui'
import { env, serviceConfig } from '../config'

export default fastifyPlugin(async (fastify: FastifyInstance) => {
    const fetchServiceSchema = async (serviceName, config) => {
        try {
            const response = await fetch(`${config.upstream}/schema`)

            if (!response.ok) {
                throw new Error(`Ошибка получения схемы от ${serviceName}`)
            }

            return await response.json()
        } catch (error) {
            fastify.log.error(
                `Не удалось получить схему от ${serviceName}: ${error.message}`
            )
            return null
        }
    }

    const buildCombinedSchema = async () => {
        const baseSchema = {
            openapi: '3.0.0',
            info: {
                title: 'StoryCraft API',
                description: 'Полная документация API для StoryCraft',
                version: '1.0.0',
            },
            paths: {},
            components: {
                securitySchemes: {
                    bearerAuth: {
                        type: 'http',
                        scheme: 'bearer',
                        bearerFormat: 'JWT',
                    },
                },
                schemas: {},
                responses: {},
                parameters: {},
                examples: {},
                requestBodies: {},
                headers: {},
            },
            tags: [
                {
                    name: 'Auth',
                    description: 'Методы для работы с авторизацией',
                },
                {
                    name: 'Stories',
                    description: 'Методы для работы с историями',
                },
            ],
        }

        const serviceSchemas = {}
        const fetchPromises = Object.entries(serviceConfig)
            .filter(([_, config]) => config.swaggerEnabled)
            .map(async ([serviceName, config]) => {
                const schema = await fetchServiceSchema(serviceName, config)
                
                if (schema) {
                    serviceSchemas[serviceName] = schema
                }
            })

        await Promise.all(fetchPromises)

        for (const [serviceName, schema] of Object.entries(serviceSchemas)) {
            const config = serviceConfig[serviceName]
            const prefix = config.prefix || serviceName

            if (schema.tags) {
                for (const tag of schema.tags) {
                    if (!baseSchema.tags.some((t) => t.name === tag.name)) {
                        baseSchema.tags.push(tag)
                    }
                }
            }

            if (schema.paths) {
                for (const [path, pathData] of Object.entries(schema.paths)) {
                    const normalizedPath = path.startsWith('/')
                        ? `/${prefix}${path}`
                        : `/${prefix}/${path}`

                    const cleanedPath = normalizedPath.replace(/\/+/g, '/')
                    baseSchema.paths[cleanedPath] = pathData
                }
            }

            if (schema.components) {
                for (const componentType of [
                    'schemas',
                    'responses',
                    'parameters',
                    'examples',
                    'requestBodies',
                    'headers',
                    'links',
                    'callbacks',
                ]) {
                    if (schema.components[componentType]) {
                        baseSchema.components[componentType] = {
                            ...(baseSchema.components[componentType] || {}),
                            ...schema.components[componentType],
                        }
                    }
                }
            }
        }

        return baseSchema
    }

    await fastify.register(fastifySwagger, {
        mode: 'static',
        specification: {
            document: (await buildCombinedSchema()) as any,
        },
    })

    await fastify.register(fastifySwaggerUi, {
        routePrefix: '/docs',
        uiConfig: {
            docExpansion: 'list',
            persistAuthorization: true,
            deepLinking: false,
        },
        staticCSP: true,
    })

    fastify.get('/api-json', async (request, reply) => {
        const schema = await buildCombinedSchema()
        return schema
    })
})
</file>

<file path="services/auth-service/src/config.ts">
interface Config {
    port: number
    nodeEnv: string
    jwtSecret: string
    jwtAccessTokenExpiresIn: number
    jwtRefreshTokenExpiresIn: number
    logLevel: string
    database: {
        url: string
    }
}

const getConfig = (): Config => {
    return {
        port: getEnvNumber('PORT', 3001),
        nodeEnv: getEnvString('NODE_ENV', 'dev'),
        logLevel: getEnvString('LOG_LEVEL', 'info'),
        jwtAccessTokenExpiresIn: getEnvNumber('JWT_ACCESS_EXPIRES', 15 * 60),
        jwtRefreshTokenExpiresIn: getEnvNumber(
            'JWT_REFRESH_EXPIRES',
            7 * 24 * 60 * 60
        ),
        jwtSecret: getEnvString('JWT_SECRET'),
        database: {
            url: getEnvString('DATABASE_URL'),
        },
    }
}

const getEnvString = (key: string, defaultValue?: string): string => {
    const value = process.env[key] || defaultValue
    if (value === undefined) {
        throw new Error(`Environment variable ${key} is not set`)
    }
    return value
}

const getEnvNumber = (key: string, defaultValue?: number): number => {
    const stringValue = process.env[key]
    if (stringValue === undefined) {
        if (defaultValue !== undefined) {
            return defaultValue
        }
        throw new Error(`Environment variable ${key} is not set`)
    }

    const numValue = Number(stringValue)
    if (isNaN(numValue)) {
        throw new Error(`Environment variable ${key} is not a number`)
    }

    return numValue
}

const config = getConfig()

export default config
</file>

<file path="services/auth-service/src/index.ts">
import ExpressServer from './server'
import config from './config'

export const app = new ExpressServer().app
export const server = app.listen(config.port, () => {
    console.log(
        `Server listening on port ${config.port} in ${config.nodeEnv} mode`
    )
})
</file>

<file path="services/auth-service/src/middlewares/protect-route.middleware.ts">
import { verifyAccessToken } from '../lib/auth'
import { Request, Response, NextFunction } from 'express'
import { UnauthorizedError } from '../utils/errors'

export const protectRoute = async (
    req: Request,
    res: Response,
    next: NextFunction
) => {
    try {
        const bearer = req.headers.authorization

        if (!bearer || !bearer.startsWith('Bearer ')) {
            throw new UnauthorizedError('No access token provided')
        }

        const token = bearer.split(' ')[1]
        const payload = verifyAccessToken(token)

        if (!payload) {
            throw new UnauthorizedError('Invalid or expired access token')
        }

        console.log(payload)

        req.user = payload
        next()
    } catch (error) {
        next(error)
    }
}
</file>

<file path="services/auth-service/src/types/express.d.ts">
import { TokenPayload } from 'storycraft-common-types'

declare global {
    namespace Express {
        interface Request {
            user?: TokenPayload
        }
    }
}
</file>

<file path="services/auth-service/tsconfig.json">
{
    "compilerOptions": {
        "target": "ES2024", // Уровень стандартов JavaScript
        "module": "NodeNext", // Использование стандартных ES модулей
        "moduleResolution": "nodenext", // Разрешение модулей по алгоритму Node.js
        "lib": ["ES2024"], // Подключаемые библиотеки
        "outDir": "./dist", // Выходная директория для скомпилированных файлов
        "rootDir": "./src", // Корневая директория исходных файлов
        "esModuleInterop": true, // Поддержка импорта CommonJS модулей
        "strict": false,
        "forceConsistentCasingInFileNames": true, // Контроль регистра символов в путях файлов
        "skipLibCheck": true, // Пропуск проверки типов в файлах .d.ts
        "resolveJsonModule": true, // Разрешение импорта JSON модулей
        "allowJs": true // Разрешение компиляции JS файлов,
        // "allowSyntheticDefaultImports": true // Разрешение импорта модулей с экспортом по умолчанию
    },
    "include": ["src"],
    "exclude": ["node_modules", "**/*.spec.ts"]
}
</file>

<file path="services/common-types/package.json">
{
    "name": "storycraft-common-types",
    "version": "1.0.1",
    "description": "Общие типы для микросервисов StoryСraft",
    "main": "dist/index.js",
    "types": "dist/index.d.ts",
    "files": [
        "dist"
    ],
    "scripts": {
        "build": "tsc",
        "prepare": "npm run build"
    },
    "keywords": [
        "typescript",
        "types",
        "storycraft"
    ],
    "author": "Tomato1377",
    "license": "MIT",
    "devDependencies": {
        "typescript": "^5.3.3"
    }
}
</file>

<file path="services/common-types/src/auth.ts">
export interface TokenPayload {
    userId: string
}
</file>

<file path="services/story-service/prisma/schema.prisma">
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
    provider      = "prisma-client-js"
    binaryTargets = ["native", "linux-musl-openssl-3.0.x", "windows"]
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

enum Role {
    USER
    AUTHOR
    ADMIN
}

enum Phase {
    PROPOSAL
    VOTING
}

model Story {
    id                 String              @id @default(uuid())
    title              String              @db.VarChar(255)
    description        String              @db.Text
    coverImageUrl      String?             @db.VarChar(255)
    authorId           String
    isActive           Boolean             @default(true)
    isPublic           Boolean             @default(true)
    currentPhase       Phase               @default(PROPOSAL)
    proposalTime       Int                 @default(0)
    votingTime         Int                 @default(0)
    viewCount          Int                 @default(0)
    proposalDeadline   DateTime?           @db.Timestamp()
    votingDeadline     DateTime?           @db.Timestamp()
    storyCollaborators StoryCollaborator[]
    chapters           Chapter[]
    genres             Genre[]

    createdAt DateTime @default(now())
    updatedAt DateTime @default(now()) @updatedAt
}

model Genre {
    id   String @id @default(uuid())
    name String @db.VarChar(255)

    stories Story[]
}

model StoryCollaborator {
    id      String @id @default(uuid())
    storyId String
    userId  String
    role    Role   @default(USER)

    story Story @relation(fields: [storyId], references: [id], onDelete: Cascade)

    createdAt DateTime @default(now())
    updatedAt DateTime @default(now()) @updatedAt
}

model Chapter {
    id              String            @id @default(uuid())
    title           String            @db.VarChar(255)
    content         String            @db.Text
    authorId        String
    position        Int
    isLastChapter   Boolean           @default(false)
    storyId         String
    chapterProposal ChapterProposal[]

    story Story @relation(fields: [storyId], references: [id], onDelete: Cascade)

    createdAt DateTime @default(now())
    updatedAt DateTime @default(now()) @updatedAt
}

model ChapterProposal {
    id              String  @id @default(uuid())
    title           String  @db.VarChar(255)
    content         String  @db.Text
    authorId        String
    storyId         String
    parentChapterId String
    voteCount       Int     @default(0)
    hasWon          Boolean @default(false)
    votes           Vote[]

    parentChapter Chapter @relation(fields: [parentChapterId], references: [id], onDelete: Cascade)

    createdAt DateTime @default(now())
    updatedAt DateTime @default(now()) @updatedAt
}

model Vote {
    id                String @id @default(uuid())
    authorId          String
    chapterProposalId String

    chapterProposal ChapterProposal @relation(fields: [chapterProposalId], references: [id], onDelete: Cascade)

    createdAt DateTime @default(now())
    updatedAt DateTime @default(now()) @updatedAt
}
</file>

<file path="services/story-service/prisma/seed.ts">
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

const genres = [
    { name: 'Фэнтези' },
    { name: 'Научная фантастика' },
    { name: 'Детектив' },
    { name: 'Приключения' },
    { name: 'Романтика' },
    { name: 'Драма' },
    { name: 'Комедия' },
    { name: 'Хоррор' },
    { name: 'Историческая фантастика' },
    { name: 'Альтернативная история' },
    { name: 'Фантастика' },
    { name: 'Ужасы' },
    { name: 'Мистика' },
    { name: 'Триллер' },
    { name: 'Сказка' },
    { name: 'ЛитРПГ' },
    { name: 'Киберпанк' },
    { name: 'Постапокалипсис' },
    { name: 'Юмор' },
    { name: 'Спорт' },
    { name: 'Семейная сага' },
    { name: 'Приключенческий роман' },
    { name: 'Эротика' },
]

async function main() {
    console.log(`Начинаем заполнение жанров...`)

    for (const genre of genres) {
        const existingGenre = await prisma.genre.findFirst({
            where: { name: genre.name },
        })

        if (!existingGenre) {
            await prisma.genre.create({
                data: genre,
            })
            console.log(`Создан жанр: ${genre.name}`)
        } else {
            console.log(`Жанр уже существует: ${genre.name}`)
        }
    }

    console.log(`Заполнение жанров завершено!`)
}

main()
    .catch((e) => {
        console.error(e)
        process.exit(1)
    })
    .finally(async () => {
        await prisma.$disconnect()
    })
</file>

<file path="services/story-service/src/controllers/genre.controller.ts">
import { FastifyReply, FastifyRequest } from 'fastify'
import { genreService } from '../services/genre.service'
import { GetAllGenresResponse } from '../model/genre.model'

export const genreController = {
    async getAllGenres(request: FastifyRequest, reply: FastifyReply) {
        try {
            const genres = await genreService.getAllGenres()
            const response: GetAllGenresResponse = {
                count: genres.length,
                genres: genres.map((g) => ({ id: g.id, name: g.name })),
            }
            return reply.code(200).send(response)
        } catch (error) {
            request.log.error(error)
            return reply.status(500).send({ error: 'Internal Server Error' })
        }
    },
}
</file>

<file path="services/story-service/src/model/genre.model.ts">
import z from 'zod'

export const createGenreSchema = z.object({
    name: z
        .string()
        .min(3, 'Название должно содержать минимум 3 символа')
        .max(255),
})

export type CreateGenreInput = z.infer<typeof createGenreSchema>

export const genreResponseSchema = z.object({
    id: z.string().uuid(),
    name: z.string(),
})

export const getAllGenresResponseSchema = z.object({
    count: z.number(),
    genres: z.array(genreResponseSchema),
})
export type GetAllGenresResponse = z.infer<typeof getAllGenresResponseSchema>
</file>

<file path="services/story-service/src/plugins/authenticate.ts">
import fp from 'fastify-plugin'
import { FastifyInstance, FastifyReply, FastifyRequest } from 'fastify'
import { TokenPayload } from 'storycraft-common-types'
import { UnauthorizedError } from '../utils/errors'

export default fp(async (app: FastifyInstance) => {
    app.decorateRequest('user', null)

    app.decorate(
        'authenticate',
        async (request: FastifyRequest, reply: FastifyReply) => {
            const userObjectHeader = request.headers['x-user-object']
            if (!userObjectHeader) {
                throw new UnauthorizedError('Unauthorized')
            }

            try {
                const userObject: TokenPayload = JSON.parse(
                    userObjectHeader as string
                )

                if (!userObject || !userObject.userId) {
                    throw new UnauthorizedError('Invalid user data')
                }

                request.user = userObject

                app.log.info(`User authenticated: ${userObject.userId}`)
            } catch (error) {
                app.log.error(`Invalid user object: ${error.message}`)
                throw new UnauthorizedError('Invalid user data')
            }
        }
    )

    app.decorate(
        'authenticateOptional',
        async (request: FastifyRequest, reply: FastifyReply) => {
            const userObjectHeader = request.headers['x-user-object']

            if (!userObjectHeader) {
                app.log.info(
                    'No user authentication provided, continuing as guest'
                )
                return // Просто возвращаемся без установки request.user
            }

            try {
                const userObject: TokenPayload = JSON.parse(
                    userObjectHeader as string
                )

                if (userObject && userObject.userId) {
                    request.user = userObject
                    app.log.info(`User authenticated: ${userObject.userId}`)
                } else {
                    app.log.info('Invalid user data, continuing as guest')
                }
            } catch (error) {
                // В случае ошибки парсинга просто логируем и продолжаем без авторизации
                app.log.warn(`Could not parse user object: ${error.message}`)
            }
        }
    )
})
</file>

<file path="services/story-service/src/routes/chapter.route.ts">
import {
    FastifyPluginAsyncZod,
    ZodTypeProvider,
} from 'fastify-type-provider-zod'
import z from 'zod'
import { chapterController } from '../controllers/chapter.controller'
import {
    proposeChapterSchema,
    proposalResponseSchema,
    voteResponseSchema,
    paginatedChapterResponseSchema,
    paginatedProposalResponseSchema,
    createChapterSchema,
    chapterResponseSchema,
} from '../model/chapter.model'

export const chapterRoutes: FastifyPluginAsyncZod = async (app, options) => {
    app.withTypeProvider<ZodTypeProvider>().route({
        method: 'GET',
        url: '/:storyId/chapters',
        schema: {
            tags: ['Stories'],
            description: 'Get all chapters for a story',
            params: z.object({ storyId: z.string().uuid() }),
            querystring: z.object({
                page: z.coerce.number().optional(),
                pageSize: z.coerce.number().optional(),
            }),
            response: { 200: paginatedChapterResponseSchema },
        },
        handler: chapterController.getChapters,
    })

    app.withTypeProvider<ZodTypeProvider>().route({
        method: 'GET',
        url: '/:storyId/chapters/:chapterId',
        schema: {
            tags: ['Stories'],
            description: 'Get chapter by ID',
            params: z.object({
                storyId: z.string().uuid(),
                chapterId: z.string().uuid(),
            }),
            response: { 200: chapterResponseSchema },
        },
        handler: chapterController.getChapterById,
    })

    app.withTypeProvider<ZodTypeProvider>().route({
        method: 'POST',
        url: '/:storyId/chapters/:chapterId/proposals',
        preValidation: [app.authenticate],
        schema: {
            tags: ['Stories'],
            description: 'Propose a new chapter for a story',
            security: [{ bearerAuth: [] }],
            params: z.object({
                storyId: z.string().uuid(),
                chapterId: z.string().uuid(),
            }),
            body: proposeChapterSchema,
            response: { 201: proposalResponseSchema },
        },
        handler: chapterController.createProposeChapter,
    })

    app.withTypeProvider<ZodTypeProvider>().route({
        method: 'DELETE',
        url: '/:storyId/chapters/:chapterId/proposals/:proposalId',
        preValidation: [app.authenticate],
        schema: {
            tags: ['Stories'],
            description: 'Delete a proposal',
            security: [{ bearerAuth: [] }],
            params: z.object({
                storyId: z.string().uuid(),
                chapterId: z.string().uuid(),
                proposalId: z.string().uuid(),
            }),
            response: {
                204: z.object({
                    status: z.boolean(),
                }),
            },
        },
        handler: chapterController.deleteProposalById,
    })

    app.withTypeProvider<ZodTypeProvider>().route({
        method: 'PATCH',
        url: '/:storyId/chapters/:chapterId/proposals/:proposalId',
        preValidation: [app.authenticate],
        schema: {
            tags: ['Stories'],
            description: 'Change a proposal in PROPOSAL phase',
            security: [{ bearerAuth: [] }],
            params: z.object({
                storyId: z.string().uuid(),
                chapterId: z.string().uuid(),
                proposalId: z.string().uuid(),
            }),
            body: createChapterSchema,
            response: {
                204: proposalResponseSchema,
            },
        },
        handler: chapterController.changeProposalById,
    })

    app.withTypeProvider<ZodTypeProvider>().route({
        method: 'GET',
        url: '/:storyId/chapters/:chapterId/proposals',
        schema: {
            tags: ['Stories'],
            description: 'Get all proposals for a chapter',
            params: z.object({
                storyId: z.string().uuid(),
                chapterId: z.string().uuid(),
            }),
            querystring: z.object({
                page: z.coerce.number().optional(),
                pageSize: z.coerce.number().optional(),
            }),
            response: { 200: paginatedProposalResponseSchema },
        },
        handler: chapterController.getProposals,
    })

    app.withTypeProvider<ZodTypeProvider>().route({
        method: 'GET',
        url: '/:storyId/chapters/:chapterId/proposals/:proposalId',
        schema: {
            tags: ['Stories'],
            description: 'Get a proposal by ID',
            params: z.object({
                storyId: z.string().uuid(),
                chapterId: z.string().uuid(),
                proposalId: z.string().uuid(),
            }),
            response: { 200: proposalResponseSchema },
        },
        handler: chapterController.getProposalById,
    })

    app.withTypeProvider<ZodTypeProvider>().route({
        method: 'POST',
        url: '/proposals/:proposalId/vote',
        preValidation: [app.authenticate],
        schema: {
            tags: ['Stories'],
            description: 'Vote for a proposal',
            security: [{ bearerAuth: [] }],
            params: z.object({ proposalId: z.string().uuid() }),
            response: { 200: voteResponseSchema },
        },
        handler: chapterController.voteProposal,
    })

    app.withTypeProvider<ZodTypeProvider>().route({
        method: 'DELETE',
        url: '/proposals/:proposalId/vote',
        preValidation: [app.authenticate],
        schema: {
            tags: ['Stories'],
            description: 'Remove vote for a proposal',
            security: [{ bearerAuth: [] }],
            params: z.object({ proposalId: z.string().uuid() }),
            response: { 200: voteResponseSchema },
        },
        handler: chapterController.deleteVoteProposal,
    })

    app.withTypeProvider<ZodTypeProvider>().route({
        method: 'POST',
        url: '/proposals/:proposalId/select-winner',
        preValidation: [app.authenticate],
        schema: {
            tags: ['Stories'],
            description: 'Select a winner proposal',
            security: [{ bearerAuth: [] }],
            params: z.object({ proposalId: z.string().uuid() }),
            response: { 200: proposalResponseSchema },
        },
        handler: chapterController.selectWinnerProposal,
    })
}
</file>

<file path="services/story-service/src/routes/genre.route.ts">
import {
    FastifyPluginAsyncZod,
    ZodTypeProvider,
} from 'fastify-type-provider-zod'
import { getAllGenresResponseSchema } from '../model/genre.model'
import { genreController } from '../controllers/genre.controller'

export const genreRoutes: FastifyPluginAsyncZod = async (app, options) => {
    app.withTypeProvider<ZodTypeProvider>().route({
        method: 'GET',
        url: '/',
        schema: {
            tags: ['Stories'],
            description: 'Get all genres',
            response: {
                200: getAllGenresResponseSchema,
            },
        },
        handler: genreController.getAllGenres,
    })
}
</file>

<file path="services/story-service/src/routes/index.ts">
import {
    FastifyPluginAsyncZod,
    ZodTypeProvider,
} from 'fastify-type-provider-zod'
import z from 'zod'
import { env } from '../config'
import { storyRoutes } from './story.route'
import { genreRoutes } from './genre.route'
import { chapterRoutes } from './chapter.route'

export const routes: FastifyPluginAsyncZod = async (app, options) => {
    app.register(storyRoutes)
    app.register(chapterRoutes)
    app.register(genreRoutes, { prefix: '/genres' })

    app.withTypeProvider<ZodTypeProvider>().route({
        method: 'GET',
        url: '/health',
        schema: {
            tags: ['Stories'],
            description: 'Health check endpoint.',
            response: {
                201: z.object({
                    status: z.string(),
                    timestamp: z.date(),
                    environment: z.string(),
                }),
            },
        },
        handler: async (request, reply) => {
            return {
                status: 'ok',
                timestamp: new Date(),
                environment: env.NODE_ENV,
            }
        },
    })

    app.withTypeProvider<ZodTypeProvider>().route({
        method: 'GET',
        url: '/schema',
        schema: {
            tags: ['Stories'],
            description:
                'Get OpenAPI schema. This schema will be imported in the API Gateway.',
        },
        handler: async (request, reply) => {
            return reply.send(app.swagger())
        },
    })

    app.setNotFoundHandler((request, reply) => {
        reply.status(404).send({
            statusCode: 404,
            error: 'Not Found',
            message: `Route ${request.method}:${request.url} not found`,
        })
    })
}
</file>

<file path="services/story-service/src/routes/story.route.ts">
import {
    FastifyPluginAsyncZod,
    ZodTypeProvider,
} from 'fastify-type-provider-zod'
import {
    createStorySchema,
    paginatedStoryResponseSchema,
    storyResponseSchema,
    updateStorySchema,
} from '../model/story.model'
import { storyController } from '../controllers/story.controller'
import z from 'zod'

export const storyRoutes: FastifyPluginAsyncZod = async (app, options) => {
    app.withTypeProvider<ZodTypeProvider>().route({
        method: 'GET',
        url: '/',
        preValidation: [app.authenticateOptional],
        schema: {
            tags: ['Stories'],
            description: 'Get all stories',
            querystring: z.object({
                page: z.coerce.number().optional(),
                pageSize: z.coerce.number().optional(),
            }),
            response: {
                200: paginatedStoryResponseSchema,
            },
        },
        handler: storyController.getAllStory,
    })

    app.withTypeProvider<ZodTypeProvider>().route({
        method: 'GET',
        url: '/my',
        preValidation: [app.authenticate],
        schema: {
            tags: ['Stories'],
            description: 'Get my stories',
            security: [{ bearerAuth: [] }],
            querystring: z.object({
                page: z.coerce.number().optional(),
                pageSize: z.coerce.number().optional(),
            }),
            response: {
                200: paginatedStoryResponseSchema,
            },
        },
        handler: storyController.getMyStories,
    })

    app.withTypeProvider<ZodTypeProvider>().route({
        method: 'POST',
        url: '/',
        preValidation: [app.authenticate],
        schema: {
            tags: ['Stories'],
            description: 'Create a new story',
            security: [{ bearerAuth: [] }],
            body: createStorySchema,
            response: {
                200: storyResponseSchema,
            },
        },
        handler: storyController.createStory,
    })

    app.withTypeProvider<ZodTypeProvider>().route({
        method: 'GET',
        url: '/:storyId',
        schema: {
            tags: ['Stories'],
            description: 'Get story by ID',
            params: z.object({ storyId: z.string().uuid() }),
            response: {
                200: storyResponseSchema,
            },
        },
        handler: storyController.getStoryById,
    })

    app.withTypeProvider<ZodTypeProvider>().route({
        method: 'PATCH',
        url: '/:storyId',
        preValidation: [app.authenticate],
        schema: {
            tags: ['Stories'],
            description: 'Update a story',
            security: [{ bearerAuth: [] }],
            params: z.object({ storyId: z.string().uuid() }),
            body: updateStorySchema,
            response: {
                200: storyResponseSchema,
            },
        },
        handler: storyController.updateStoryById,
    })

    app.withTypeProvider<ZodTypeProvider>().route({
        method: 'DELETE',
        url: '/:storyId',
        preValidation: [app.authenticate],
        schema: {
            tags: ['Stories'],
            description: 'Delete a story',
            security: [{ bearerAuth: [] }],
            params: z.object({ storyId: z.string().uuid() }),
            response: {
                204: z.object({
                    success: z.boolean(),
                }),
            },
        },
        handler: storyController.deleteStoryById,
    })
}
</file>

<file path="services/story-service/src/services/collaborator.service.ts">
import { prisma } from '../prisma'

export const collaboratorService = {
    async getStoryCollaborators(storyId: string) {
        return prisma.storyCollaborator
            .findMany({
                where: { storyId },
            })
            .then((collaborators) => {
                return collaborators.map((collaborator) => ({
                    id: collaborator.id,
                    userId: collaborator.userId,
                    role: collaborator.role,
                }))
            })
    },

    async addCollaboratorInStory(storyId: string, collaboratorId: string) {
        const findUser = await prisma.storyCollaborator.findFirst({
            where: {
                storyId,
                userId: collaboratorId,
            },
        })

        if (!findUser) {
            return prisma.storyCollaborator.create({
                data: {
                    storyId,
                    userId: collaboratorId,
                },
            })
        } else {
            return findUser
        }
    },
}
</file>

<file path="services/story-service/src/types/fastify.d.ts">
import { TokenPayload } from 'storycraft-common-types'

declare module 'fastify' {
    interface FastifyRequest {
        user: TokenPayload | null
    }

    interface FastifyInstance {
        authenticate: (request: FastifyRequest, reply: FastifyReply) => void
        authenticateOptional: (
            request: FastifyRequest,
            reply: FastifyReply
        ) => void
    }
}
</file>

<file path="services/story-service/tsconfig.json">
{
    "compilerOptions": {
        "target": "ES2024", // Уровень стандартов JavaScript
        "module": "NodeNext", // Использование стандартных ES модулей
        "moduleResolution": "nodenext", // Разрешение модулей по алгоритму Node.js
        "lib": ["ES2024"], // Подключаемые библиотеки
        "outDir": "./dist", // Выходная директория для скомпилированных файлов
        "rootDir": "./src", // Корневая директория исходных файлов
        "esModuleInterop": true, // Поддержка импорта CommonJS модулей
        "strict": true,
        "forceConsistentCasingInFileNames": true, // Контроль регистра символов в путях файлов
        "skipLibCheck": true, // Пропуск проверки типов в файлах .d.ts
        "resolveJsonModule": true, // Разрешение импорта JSON модулей
        "allowJs": true // Разрешение компиляции JS файлов,
        // "allowSyntheticDefaultImports": true // Разрешение импорта модулей с экспортом по умолчанию
    },
    "include": ["src", "tests"],
    "exclude": ["node_modules", "**/*.spec.ts"]
}
</file>

<file path="services/story-service/vitest.config.ts">
import { defineConfig } from 'vitest/config'

export default defineConfig({
    test: {
        globals: true,
        environment: 'node',
        include: ['src/**/*.test.ts'],
    },
})
</file>

<file path="services/user-profile-service/Dockerfile">
FROM golang:1.23 AS builder

WORKDIR /app

# COPY go.mod go.sum ./

# Копируем все файлы сервиса: app, router, utils и т.д.
COPY . .
RUN go mod download

# Сборка бинаря из папки app
RUN go build -o main ./app

FROM debian:bookworm-slim

RUN useradd -m appuser

COPY --from=builder /app/main /usr/local/bin/main

USER appuser

EXPOSE 8080

CMD ["main"]
</file>

<file path="services/user-profile-service/models/profile.go">
package models

import (
	"time"

	"github.com/google/uuid"
	"gorm.io/gorm"
)

type Profile struct {
	ID          uuid.UUID              `gorm:"type:uuid;default:uuid_generate_v4();primaryKey" json:"id"`
	UserID      string                 `gorm:"type:uuid;not null;unique;comment:'ID из Auth сервиса'" json:"user_id"`
	Username    string                 `gorm:"size:255;not null;unique" json:"username"`
	Email       string                 `gorm:"size:255;not null;unique" json:"email"`
	DisplayName string                 `gorm:"size:255" json:"display_name"`
	Bio         string                 `gorm:"type:text" json:"bio"`
	Role        string                 `gorm:"size:50;not null;default:'user'" json:"role"`
	AvatarURL   string                 `gorm:"size:255" json:"avatar_url"`
	Preferences map[string]interface{} `gorm:"type:jsonb;not null;default:'{}'" json:"preferences"`
	LastSeen    *time.Time             `gorm:"type:timestamp" json:"last_seen"`
	CreatedAt   time.Time              `gorm:"type:timestamp;not null;default:now()" json:"created_at"`
	UpdatedAt   time.Time              `gorm:"type:timestamp;not null;default:now()" json:"updated_at"`
	DeletedAt   gorm.DeletedAt         `gorm:"index" json:"-"`
}

type InputProfile struct {
	UserID    string `json:"userId"`
	Email     string `json:"email"`
	Role      string `json:"role"`
	Username  string `json:username`
	AvatarURL string `json:"avatarUrl"`
}

// TableName определяет имя таблицы в базе данных
func (Profile) TableName() string {
	return "user_profiles"
}
</file>

<file path="services/user-profile-service/router/router.go">
package router

import (
	"github.com/monst/story-craft/services/user-profile-service/handlers"

	"github.com/gin-gonic/gin"
	"gorm.io/gorm"
)

func SetupRouter(db *gorm.DB) *gin.Engine {
	r := gin.Default()

	profiles := r.Group("/profiles")
	{
		profileHandler := handlers.NewProfileHandler(db)
		profiles.POST("/", profileHandler.CreateProfile)
		profiles.GET("/:user_id", profileHandler.GetProfile)
		profiles.PATCH("/:user_id", profileHandler.UpdateProfile)
		profiles.DELETE("/:user_id", profileHandler.DeleteProfile)
	}

	return r
}
</file>

<file path="stop-all.bat">
docker compose -f docker-compose.db.yml -f docker-compose.dev.yml -f docker-compose.prod.yml down
</file>

<file path="stop-all.sh">
docker compose -f docker-compose.db.yml -f docker-compose.dev.yml -f docker-compose.prod.yml down
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

test-results/
playwright-report/
</file>

<file path="docker-compose.prod.yml">
version: '3.8'
# !!! Для внутренних сервисов добавляем сеть backend
networks:
  frontend:
  backend:
    internal: true
services:
  api-gateway:
    build:
      context: ./services/api-gateway
      dockerfile: Dockerfile.prod
    ports:
      - ${API_GATEWAY_PORT}:${API_GATEWAY_PORT}
    environment:
      - PORT=${API_GATEWAY_PORT}
      - NODE_ENV=prod
      - PORT_AUTH_SERVICE=${AUTH_SERVICE_PORT}
      - PORT_STORY_SERVICE=${STORY_SERVICE_PORT}
      - PORT_USER_SERVICE=${USER_SERVICE_PORT}
      - PORT_MEDIA_SERVICE=${MEDIA_SERVICE_PORT}
      - PORT_SOCIAL_SERVICE=${SOCIAL_SERVICE_PORT}
      - PORT_NOTIFICATION_SERVICE=${NOTIFICATION_SERVICE_PORT}
    depends_on:
      - auth-service
    env_file:
      - .env
    networks:
      - frontend
      - backend
  auth-service:
    build:
      context: ./services/auth-service
      dockerfile: Dockerfile.prod
    ports:
      - ${AUTH_SERVICE_PORT}:${AUTH_SERVICE_PORT}
    environment:
      - PORT=${AUTH_SERVICE_PORT}
      - NODE_ENV=prod
      - DATABASE_URL=postgresql://${DB_USER}:${DB_PASSWORD}@postgres:5432/storycraft_auth
    depends_on:
      postgres:
        condition: service_healthy
    env_file:
      - .env
    networks:
      - backend
  story-service:
    build:
      context: ./services/story-service
      dockerfile: Dockerfile.prod
    ports:
      - ${STORY_SERVICE_PORT}:${STORY_SERVICE_PORT}
    environment:
      - PORT=${STORY_SERVICE_PORT}
      - NODE_ENV=prod
      - DATABASE_URL=postgresql://${DB_USER}:${DB_PASSWORD}@postgres:5432/storycraft_story
    depends_on:
      postgres:
        condition: service_healthy
    env_file:
      - .env
    networks:
      - backend
</file>

<file path="services/api-gateway/Dockerfile.dev">
FROM node:20-slim

WORKDIR /app

COPY package*.json ./
RUN npm install

COPY . .

CMD ["/bin/sh", "-c", "npm install && npm run dev"]
</file>

<file path="services/api-gateway/src/config.ts">
import z from 'zod'

const envSchema = z.object({
    NODE_ENV: z.enum(['dev', 'prod']).default('dev'),
    PORT: z.string().default('3000').transform(Number),
    PORT_AUTH_SERVICE: z.string().default('3001').transform(Number),
    PORT_STORY_SERVICE: z.string().default('3002').transform(Number),
    PORT_USER_SERVICE: z.string().default('3003').transform(Number),
    PORT_MEDIA_SERVICE: z.string().default('3004').transform(Number),
    PORT_SOCIAL_SERVICE: z.string().default('3005').transform(Number),
    JWT_SECRET: z.string().default('supersecret'),
    PORT_NOTIFICATION_SERVICE: z.string().default('3006').transform(Number),
    HOST: z.string().default('0.0.0.0'),
    LOG_LEVEL: z
        .enum(['fatal', 'error', 'warn', 'info', 'debug', 'trace', 'silent'])
        .default('info'),
})

export const env = (() => {
    try {
        return envSchema.parse(process.env)
    } catch (error) {
        if (error instanceof z.ZodError) {
            console.error(
                '❌ Invalid environment variables:',
                JSON.stringify(error.format(), null, 2)
            )
            process.exit(1)
        }
        throw error
    }
})()

const serviceConfigSchema = z.object({
    prefix: z.string().startsWith('/'),
    upstream: z.string().url(),
    swaggerEnabled: z.boolean().default(false),
})

type ServiceConfig = z.infer<typeof serviceConfigSchema>

const validateServiceConfig = (
    config: Record<string, ServiceConfig>
): Record<string, ServiceConfig> => {
    Object.entries(config).forEach(([service, conf]) => {
        try {
            serviceConfigSchema.parse(conf)
        } catch (error) {
            if (error instanceof z.ZodError) {
                console.error(
                    `❌ Invalid configuration for ${service} service:`,
                    JSON.stringify(error.format(), null, 2)
                )
                process.exit(1)
            }
            throw error
        }
    })
    return config
}

const getServiceHost = (serviceName: string): string => {
    const suffix = env.NODE_ENV === 'dev' ? '-dev' : ''
    return `${serviceName}${suffix}`
}

export const serviceConfig = validateServiceConfig({
    auth: {
        prefix: '/auth',
        upstream: `http://${getServiceHost('auth-service')}:${
            env.PORT_AUTH_SERVICE
        }`,
        swaggerEnabled: true,
    },
    user: {
        prefix: '/users',
        upstream: `http://${getServiceHost('user-profile-service')}:${
            env.PORT_USER_SERVICE
        }`,
        swaggerEnabled: false,
    },
    story: {
        prefix: '/stories',
        upstream: `http://${getServiceHost('story-service')}:${
            env.PORT_STORY_SERVICE
        }`,
        swaggerEnabled: true,
    },
    media: {
        prefix: '/media',
        upstream: `http://${getServiceHost('media-service')}:${
            env.PORT_MEDIA_SERVICE
        }`,
        swaggerEnabled: false,
    },
    social: {
        prefix: '/social',
        upstream: `http://${getServiceHost('social-interaction-service')}:${
            env.PORT_SOCIAL_SERVICE
        }`,
        swaggerEnabled: false,
    },
    notification: {
        prefix: '/notifications',
        upstream: `http://${getServiceHost('notification-service')}:${
            env.PORT_NOTIFICATION_SERVICE
        }`,
        swaggerEnabled: false,
    },
})

export const commonProxyOptions = {
    rewritePrefix: '',
    httpMethods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
    timeout: 5000,
}
</file>

<file path="services/auth-service/eslint.config.mjs">
import globals from 'globals'
import pluginJs from '@eslint/js'
import tseslint from 'typescript-eslint'

/** @type {import('eslint').Linter.Config[]} */
export default [
    { files: ['**/*.{js,mjs,cjs,ts}'] },
    { languageOptions: { globals: globals.browser } },
    pluginJs.configs.recommended,
    ...tseslint.configs.recommended,
    {
        rules: {
            'no-var': 'off',
            '@typescript-eslint/no-namespace': 'off',
        },
    },
]
</file>

<file path="services/auth-service/prisma/schema.prisma">
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
    provider      = "prisma-client-js"
    binaryTargets = ["native", "linux-musl-openssl-3.0.x", "windows"]
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

enum Role {
    USER
    ADMIN
}

model User {
    id        String   @id @default(uuid())
    email     String   @unique @db.VarChar(255)
    password  String   @db.VarChar(255)
    username  String   @unique @db.VarChar(255)
    avatarUrl String?
    role      Role     @default(USER)
    createdAt DateTime @default(now())
    updatedAt DateTime @default(now())

    refreshToken RefreshToken[]
}

model RefreshToken {
    id            String    @id @default(uuid())
    token         String    @unique @db.VarChar(255)
    isRevoked     Boolean   @default(false)
    revokedAt     DateTime?
    revokedReason String?
    userId        String
    expiresAt     DateTime
    createdAt     DateTime  @default(now())
    updatedAt     DateTime  @updatedAt

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}
</file>

<file path="services/auth-service/src/lib/auth.ts">
import jwt, { Secret, JsonWebTokenError, TokenExpiredError } from 'jsonwebtoken'
import bcrypt from 'bcryptjs'
import { v4 as uuidv4 } from 'uuid'
import { prisma } from './prisma'
import config from '../config'
import { InternalServerError, UnauthorizedError } from '../utils/errors'
import { TokenPayload } from 'storycraft-common-types'

export const comparePassword = async (
    password: string,
    hash: string
): Promise<boolean> => {
    try {
        return await bcrypt.compare(password, hash)
    } catch (error) {
        console.error('Error comparing passwords:', error)
        throw new InternalServerError('Error verifying password')
    }
}

export const hashPassword = async (password: string): Promise<string> => {
    try {
        return await bcrypt.hash(password, 10)
    } catch (error) {
        console.error('Error hashing password:', error)
        throw new InternalServerError('Error creating password hash')
    }
}

export const createAccessToken = (payload: TokenPayload): string => {
    try {
        return jwt.sign(payload, config.jwtSecret as Secret, {
            expiresIn: config.jwtAccessTokenExpiresIn,
        })
    } catch (error) {
        console.error('Error creating access token:', error)
        throw new InternalServerError('Failed to generate access token')
    }
}

export const createRefreshToken = async (userId: string): Promise<string> => {
    try {
        const tokenValue = uuidv4()
        const expiresAt = new Date()
        expiresAt.setSeconds(
            expiresAt.getSeconds() + config.jwtRefreshTokenExpiresIn
        )

        const refreshToken = await prisma.refreshToken.create({
            data: {
                token: tokenValue,
                userId,
                expiresAt,
            },
        })

        return refreshToken.token
    } catch (error) {
        console.error('Error creating refresh token:', error)
        throw new InternalServerError('Failed to generate refresh token')
    }
}

export const verifyAccessToken = (token: string): TokenPayload | null => {
    try {
        return jwt.verify(token, config.jwtSecret as Secret) as TokenPayload
    } catch (error) {
        if (error instanceof TokenExpiredError) {
            console.warn('Access token expired')
            return null
        }
        if (error instanceof JsonWebTokenError) {
            console.warn('Invalid JWT token:', error.message)
            return null
        }
        console.error('JWT verification error:', error)
        return null
    }
}

export const verifyRefreshToken = async (token: string) => {
    try {
        const refreshToken = await prisma.refreshToken.findUnique({
            where: { token },
            include: { user: true },
        })

        if (!refreshToken) {
            throw new UnauthorizedError('Refresh token not found')
        }

        if (refreshToken.isRevoked) {
            throw new UnauthorizedError('Refresh token has been revoked')
        }

        if (new Date() > refreshToken.expiresAt) {
            throw new UnauthorizedError('Refresh token has expired')
        }

        return {
            userId: refreshToken.userId,
            email: refreshToken.user.email,
            role: refreshToken.user.role,
        }
    } catch (error) {
        if (error instanceof UnauthorizedError) {
            throw error
        }
        console.error('Refresh token verification error:', error)
        throw new InternalServerError('Failed to verify refresh token')
    }
}

export const revokeRefreshToken = async (
    token: string,
    reason: string = 'User logout'
) => {
    try {
        await prisma.refreshToken.update({
            where: { token },
            data: {
                isRevoked: true,
                revokedAt: new Date(),
                revokedReason: reason,
            },
        })
    } catch (error) {
        console.error('Error revoking refresh token:', error)
        throw new InternalServerError('Failed to revoke refresh token')
    }
}
</file>

<file path="services/story-service/Dockerfile.dev">
FROM node:20-slim

WORKDIR /app

RUN apt-get update -y && apt-get install -y openssl curl wget

COPY package*.json ./
RUN npm install

COPY . .

RUN npx prisma generate

# ? npm install делаем, чтобы каждый раз не перезапускать контейнер при установки новых пакетов. Docker watch отловит изменения в коде и перезапустит контейнер с данной командой
CMD ["/bin/sh", "-c", "npm install && npx prisma migrate dev && npm run prisma:seed && npm run dev"]
</file>

<file path="services/story-service/Dockerfile.prod">
FROM node:20-slim AS builder

WORKDIR /app

RUN apt-get update -y && apt-get install -y openssl

COPY package.json package-lock.json ./
RUN npm ci

COPY . .

RUN npx prisma generate
RUN npm run build

FROM node:20-slim AS production

WORKDIR /app

COPY package.json package-lock.json ./
RUN npm ci --production

COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules

COPY --from=builder /app/prisma ./prisma

CMD ["/bin/sh", "-c", "npx prisma migrate deploy && npm run start"]
</file>

<file path="services/story-service/package.json">
{
    "name": "story-service",
    "version": "1.0.0",
    "main": "index.js",
    "scripts": {
        "test": "vitest",
        "test:api": "playwright test --project=api",
        "build": "tsc",
        "start": "node dist/app.js",
        "dev": "nodemon -L --exec tsx src/app.ts",
        "prisma:seed": "tsx prisma/seed.ts"
    },
    "author": "",
    "license": "ISC",
    "description": "",
    "dependencies": {
        "@fastify/autoload": "^6.2.0",
        "@fastify/compress": "^8.0.1",
        "@fastify/cors": "^11.0.1",
        "@fastify/helmet": "^13.0.1",
        "@fastify/jwt": "^9.1.0",
        "@fastify/sensible": "^6.0.3",
        "@fastify/static": "^8.1.1",
        "@fastify/swagger": "^9.5.0",
        "@fastify/swagger-ui": "^5.2.2",
        "@prisma/client": "^6.6.0",
        "close-with-grace": "^2.2.0",
        "fastify": "^5.2.2",
        "fastify-plugin": "^5.0.1",
        "fastify-type-provider-zod": "^4.0.2",
        "nodemon": "^3.1.9",
        "pino-pretty": "^13.0.0",
        "prisma": "^6.6.0",
        "storycraft-common-types": "^1.0.1",
        "swagger-ui-dist": "^5.21.0",
        "tsx": "^4.19.3",
        "uuid": "^11.1.0",
        "zod": "^3.24.2"
    },
    "devDependencies": {
        "@eslint/js": "^9.24.0",
        "@playwright/test": "^1.52.0",
        "@types/node": "^22.14.1",
        "eslint": "^9.24.0",
        "typescript": "^5.8.3",
        "typescript-eslint": "^8.29.1",
        "vitest": "^0.31.0"
    }
}
</file>

<file path="services/story-service/src/app.ts">
import fastify from 'fastify'
import { env } from './config'
import closeWithGrace from 'close-with-grace'
import fastifySwagger from '@fastify/swagger'
import {
    jsonSchemaTransform,
    serializerCompiler,
    validatorCompiler,
} from 'fastify-type-provider-zod'
import { routes } from './routes'
import authenticate from './plugins/authenticate'
import errorHandler from './plugins/error-handler'
import { initializeTimers } from './startup'

const settingsFastify = {
    logger: {
        level: env.LOG_LEVEL,
        ...(env.NODE_ENV === 'dev' && {
            transport: {
                target: 'pino-pretty',
            },
        }),
    },
    trustProxy: true,
}

export const app = fastify(settingsFastify)

app.setValidatorCompiler(validatorCompiler)
app.setSerializerCompiler(serializerCompiler)

app.register(errorHandler)

app.register(fastifySwagger, {
    openapi: {
        info: {
            title: 'Story Service API',
            description: 'API для работы с историями, главами и жанрами',
            version: '1.0.0',
        },
        components: {
            securitySchemes: {
                bearerAuth: {
                    type: 'http',
                    scheme: 'bearer',
                    bearerFormat: 'JWT',
                },
            },
        },
    },
    transform: jsonSchemaTransform,
})

app.register(authenticate)
app.register(routes)

initializeTimers()

const start = async () => {
    try {
        await app.listen({ port: env.PORT, host: env.HOST })

        app.log.info(
            `API Gateway server running at ${env.HOST}:${env.PORT} in ${env.NODE_ENV} mode`
        )
    } catch (err) {
        app.log.error(err)
        process.exit(1)
    }
}

closeWithGrace(async ({ signal, err, manual }) => {
    if (err) {
        app.log.error(err)
    }
    app.log.info(`Closing app with ${signal}`)
    await app.close()
    if (manual) {
        process.exit(0)
    }
})

// Запуск сервера, если не в режиме тестирования Vitest
if (!process.env.VITEST) {
    start()
}
</file>

<file path="services/story-service/src/config.ts">
import z from 'zod'

const envSchema = z.object({
    NODE_ENV: z.enum(['dev', 'prod']).default('dev'),
    PORT: z.string().default('3002').transform(Number),
    HOST: z.string().default('0.0.0.0'),
    LOG_LEVEL: z
        .enum(['fatal', 'error', 'warn', 'info', 'debug', 'trace', 'silent'])
        .default('info'),
})

type Env = z.infer<typeof envSchema>

const testValues: Env = {
    NODE_ENV: 'dev',
    PORT: 3002,
    HOST: '0.0.0.0',
    LOG_LEVEL: 'info',
}

export const env: Env = process.env.VITEST
    ? testValues
    : (() => {
          try {
              return envSchema.parse(process.env)
          } catch (error) {
              if (error instanceof z.ZodError) {
                  console.error(
                      '❌ Invalid environment variables:',
                      JSON.stringify(error.format(), null, 2)
                  )
                  process.exit(1)
              }
              throw error
          }
      })()
</file>

<file path="services/story-service/src/controllers/chapter.controller.ts">
import { FastifyReply, FastifyRequest } from 'fastify'
import { proposalService } from '../services/proposal.service'
import { chapterStoryService } from '../services/chapter.service'
import { ProposeChapterInput } from '../model/chapter.model'
import { NotFoundError, UnauthorizedError } from '../utils/errors'

export const chapterController = {
    async getChapters(
        request: FastifyRequest<{
            Params: { storyId: string }
            Querystring: { page?: number; pageSize?: number }
        }>,
        reply: FastifyReply
    ) {
        const { storyId } = request.params
        const { page = 1, pageSize = 10 } = request.query
        const result = await chapterStoryService.getChaptersPaginated(
            storyId,
            page,
            pageSize
        )
        return reply.code(200).send(result)
    },

    async getChapterById(
        request: FastifyRequest<{
            Params: { storyId: string; chapterId: string }
        }>,
        reply: FastifyReply
    ) {
        const { chapterId } = request.params
        const result = await chapterStoryService.getChapterById(chapterId)

        if (!result) {
            throw new NotFoundError(`Глава с ID ${chapterId} не найдена`)
        }

        return reply.code(200).send(result)
    },

    async createProposeChapter(
        request: FastifyRequest<{
            Params: { storyId: string; chapterId: string }
            Body: ProposeChapterInput
        }>,
        reply: FastifyReply
    ) {
        if (!request.user) {
            throw new UnauthorizedError(
                'Требуется авторизация для создания предложения'
            )
        }

        const { storyId, chapterId } = request.params
        const data = request.body

        const proposal = await proposalService.createProposeChapter(
            storyId,
            chapterId,
            request.user.userId,
            data.title,
            data.content
        )

        return reply.code(201).send(proposal)
    },

    async getProposals(
        request: FastifyRequest<{
            Params: { storyId: string; chapterId: string }
            Querystring: { page?: number; pageSize?: number }
        }>,
        reply: FastifyReply
    ) {
        const { storyId, chapterId } = request.params
        const { page = 1, pageSize = 10 } = request.query
        const result = await proposalService.getProposalsPaginated(
            storyId,
            chapterId,
            page,
            pageSize
        )
        return reply.code(200).send(result)
    },

    async getProposalById(
        request: FastifyRequest<{
            Params: { storyId: string; chapterId: string; proposalId: string }
        }>,
        reply: FastifyReply
    ) {
        const { proposalId } = request.params
        const result = await proposalService.getProposalById(proposalId)

        if (!result) {
            throw new NotFoundError(`Предложение с ID ${proposalId} не найдено`)
        }

        return reply.code(200).send(result)
    },

    async voteProposal(
        request: FastifyRequest<{ Params: { proposalId: string } }>,
        reply: FastifyReply
    ) {
        if (!request.user) {
            throw new UnauthorizedError('Требуется авторизация для голосования')
        }

        const { proposalId } = request.params
        const result = await proposalService.voteProposal(
            proposalId,
            request.user.userId
        )

        return reply.code(200).send(result)
    },

    async deleteVoteProposal(
        request: FastifyRequest<{ Params: { proposalId: string } }>,
        reply: FastifyReply
    ) {
        if (!request.user) {
            throw new UnauthorizedError(
                'Требуется авторизация для отмены голоса'
            )
        }

        const { proposalId } = request.params
        const result = await proposalService.deleteVoteProposal(
            proposalId,
            request.user.userId
        )

        return reply.code(204).send(result)
    },

    async deleteProposalById(
        request: FastifyRequest<{
            Params: { storyId: string; chapterId: string; proposalId: string }
        }>,
        reply: FastifyReply
    ) {
        if (!request.user) {
            throw new UnauthorizedError(
                'Требуется авторизация для удаления предложения'
            )
        }

        const { storyId, proposalId } = request.params
        await proposalService.deleteProposal(
            proposalId,
            request.user.userId,
            storyId
        )

        return reply.status(204).send()
    },

    async changeProposalById(
        request: FastifyRequest<{
            Params: { storyId: string; chapterId: string; proposalId: string }
            Body: ProposeChapterInput
        }>,
        reply: FastifyReply
    ) {
        if (!request.user) {
            throw new UnauthorizedError(
                'Требуется авторизация для изменения предложения'
            )
        }

        const { storyId, proposalId } = request.params
        const data = request.body

        const proposal = await proposalService.changeProposal(
            proposalId,
            request.user.userId,
            storyId,
            data.title,
            data.content
        )

        return reply.code(200).send(proposal)
    },

    async selectWinnerProposal(
        request: FastifyRequest<{
            Params: { proposalId: string }
        }>,
        reply: FastifyReply
    ) {
        if (!request.user) {
            throw new UnauthorizedError(
                'Требуется авторизация для выбора победителя'
            )
        }

        const { proposalId } = request.params
        const result = await proposalService.selectWinnerProposal(
            proposalId,
            request.user.userId
        )

        return reply.code(200).send(result)
    },
}
</file>

<file path="services/story-service/src/controllers/story.controller.ts">
import { FastifyReply, FastifyRequest } from 'fastify'
import { ChangeStoryInput, CreateStoryInput } from '../model/story.model'
import { storyService } from '../services/story.service'

export const storyController = {
    async createStory(
        request: FastifyRequest<{ Body: CreateStoryInput }>,
        reply: FastifyReply
    ) {
        const story = await storyService.createStory(
            request.body,
            request.user!.userId
        )

        return reply.status(201).send(story)
    },

    async getStoryById(
        request: FastifyRequest<{ Params: { storyId: string } }>,
        reply: FastifyReply
    ) {
        const storyId = request.params.storyId
        const story = await storyService.getStoryById(storyId)

        return reply.send(story)
    },

    async updateStoryById(
        request: FastifyRequest<{
            Params: { storyId: string }
            Body: ChangeStoryInput
        }>,
        reply: FastifyReply
    ) {
        const storyId = request.params.storyId
        const updatedStory = await storyService.updateStory(
            storyId,
            request.body,
            request.user!.userId
        )

        return reply.send(updatedStory)
    },

    async getMyStories(
        request: FastifyRequest<{
            Querystring: { page?: number; pageSize?: number }
        }>,
        reply: FastifyReply
    ) {
        const stories = await storyService.getMyStoriesPaginated(
            request.user!.userId,
            request.query.page,
            request.query.pageSize
        )

        return reply.send(stories)
    },

    async deleteStoryById(
        request: FastifyRequest<{ Params: { storyId: string } }>,
        reply: FastifyReply
    ) {
        const storyId = request.params.storyId
        await storyService.deleteStory(storyId, request.user!.userId)

        return reply.status(204).send({
            success: true,
        })
    },

    async getAllStory(
        request: FastifyRequest<{
            Querystring: { page?: number; pageSize?: number }
        }>,
        reply: FastifyReply
    ) {
        const { page = 1, pageSize = 10 } = request.query
        const result = await storyService.getStoriesPaginated(
            page,
            pageSize,
            request.user?.userId
        )

        return reply.code(200).send(result)
    },
}
</file>

<file path="services/story-service/src/model/chapter.model.ts">
import { z } from 'zod'

export const createChapterSchema = z.object({
    title: z.string().min(1, 'Заголовок обязателен'),
    content: z.string().min(1, 'Содержимое обязательно'),
})
export type CreateChapterInput = z.infer<typeof createChapterSchema>

export const chapterResponseSchema = z.object({
    id: z.string().uuid(),
    title: z.string(),
    content: z.string(),
    authorId: z.string().uuid(),
    storyId: z.string().uuid(),
    position: z.number(),
    isLastChapter: z.boolean(),
    createdAt: z.date(),
    updatedAt: z.date(),
})
export type ChapterResponse = z.infer<typeof chapterResponseSchema>

export const proposeChapterSchema = z.object({
    title: z.string().min(1, 'Заголовок обязателен'),
    content: z.string().min(1, 'Содержимое обязательно'),
})
export type ProposeChapterInput = z.infer<typeof proposeChapterSchema>

export const proposalResponseSchema = z.object({
    id: z.string().uuid(),
    title: z.string(),
    content: z.string(),
    authorId: z.string().uuid(),
    storyId: z.string().uuid(),
    parentChapterId: z.string().uuid(),
    voteCount: z.number(),
    hasWon: z.boolean(),
    createdAt: z.date(),
    updatedAt: z.date(),
})
export type ProposalResponse = z.infer<typeof proposalResponseSchema>

export const voteResponseSchema = z.object({
    success: z.boolean(),
})
export type VoteResponse = z.infer<typeof voteResponseSchema>

export const paginatedChapterResponseSchema = z.object({
    items: z.array(chapterResponseSchema),
    totalCount: z.number(),
    totalPages: z.number(),
    page: z.number(),
    pageSize: z.number(),
})

export const paginatedProposalResponseSchema = z.object({
    items: z.array(proposalResponseSchema),
    totalCount: z.number(),
    totalPages: z.number(),
    page: z.number(),
    pageSize: z.number(),
})
</file>

<file path="services/story-service/src/model/story.model.ts">
import { z } from 'zod'
import { genreResponseSchema } from './genre.model'

export const initialChapterSchema = z.object({
    title: z.string().min(1),
    content: z.string().min(1),
})

export const storyCollaboratorSchema = z.object({
    id: z.string().uuid(),
    userId: z.string().uuid(),
    role: z.enum(['USER', 'ADMIN']),
})

export const storySchema = z.object({
    title: z
        .string()
        .min(3, 'Название должно содержать минимум 3 символа')
        .max(255),
    description: z
        .string()
        .min(10, 'Описание должно содержать минимум 10 символов'),
    genres: z.array(z.string()).min(1, 'Выберите хотя бы один жанр'),
    coverImageUrl: z
        .string()
        .url('Некорректная ссылка на изображение обложки')
        .optional(),
    proposalTime: z.number().default(1000 * 60 * 60),
    votingTime: z.number().default(1000 * 60 * 10),
    isPublic: z.boolean().default(true),
    storyCollaborator: storyCollaboratorSchema.optional(),
    initialChapter: initialChapterSchema,
})
export const createStorySchema = storySchema.omit({
    storyCollaborator: true,
})

// all optional:
export const updateStorySchema = storySchema
    .omit({
        initialChapter: true,
    })
    .partial()
    .refine((data) => Object.keys(data).length > 0, {
        message: 'Должно быть указано хотя бы одно поле для изменения',
    })

export type CreateStoryInput = z.infer<typeof createStorySchema>
export type ChangeStoryInput = z.infer<typeof updateStorySchema>

export const storyResponseSchema = z.object({
    id: z.string().uuid(),
    title: z.string(),
    description: z.string(),
    coverImageUrl: z.string().nullable(),
    authorId: z.string().uuid(),
    isActive: z.boolean(),
    isPublic: z.boolean(),
    currentPhase: z.enum(['PROPOSAL', 'VOTING']),
    viewCount: z.number(),
    proposalTime: z.number(),
    votingTime: z.number(),
    proposalDeadline: z.date().nullable(),
    votingDeadline: z.date().nullable(),
    createdAt: z.date(),
    updatedAt: z.date(),
    storyCollaborators: z.array(storyCollaboratorSchema),
    genres: z.array(genreResponseSchema),
})

export type StoryResponse = z.infer<typeof storyResponseSchema>

export const paginatedStoryResponseSchema = z.object({
    items: z.array(storyResponseSchema),
    totalCount: z.number(),
    totalPages: z.number(),
    page: z.number(),
    pageSize: z.number(),
})

export type PaginatedStoryResponse = z.infer<
    typeof paginatedStoryResponseSchema
>
</file>

<file path="services/story-service/src/services/chapter.service.ts">
import { prisma } from '../prisma'
import { CreateChapterInput } from '../model/chapter.model'
import { NotFoundError } from '../utils/errors'

export const chapterStoryService = {
    async createChapter(
        storyId: string,
        data: CreateChapterInput,
        authorId: string
    ) {
        const story = await prisma.story.findUnique({
            where: { id: storyId },
        })

        if (!story) {
            throw new NotFoundError(`История с ID ${storyId} не найдена`)
        }

        const count = await prisma.chapter.count({ where: { storyId } })
        const chapter = await prisma.chapter.create({
            data: {
                title: data.title,
                content: data.content,
                authorId,
                storyId,
                position: count + 1,
                isLastChapter: true,
            },
        })
        return chapter
    },

    async getChapterById(chapterId: string) {
        const chapter = await prisma.chapter.findUnique({
            where: { id: chapterId },
        })

        if (!chapter) {
            throw new NotFoundError(`Глава с ID ${chapterId} не найдена`)
        }

        return chapter
    },

    async getChaptersPaginated(
        storyId: string,
        page: number = 1,
        pageSize: number = 10
    ) {
        const story = await prisma.story.findUnique({
            where: { id: storyId },
        })

        if (!story) {
            throw new NotFoundError(`История с ID ${storyId} не найдена`)
        }

        const totalCount = await prisma.chapter.count({ where: { storyId } })
        const items = await prisma.chapter.findMany({
            where: { storyId },
            orderBy: { position: 'asc' },
            skip: (page - 1) * pageSize,
            take: pageSize,
        })

        const totalPages = Math.ceil(totalCount / pageSize) || 1
        return { items, totalCount, totalPages, page, pageSize }
    },
}
</file>

<file path="services/story-service/src/services/proposal.service.ts">
import { prisma, Phase } from '../prisma'
import {
    BadRequestError,
    ConflictError,
    ForbiddenError,
    NotFoundError,
} from '../utils/errors'
import { chapterStoryService } from './chapter.service'
import { collaboratorService } from './collaborator.service'
import { TimerService } from './time.service'

export const proposalService = {
    async createProposeChapter(
        storyId: string,
        parentChapterId: string,
        authorId: string,
        title: string,
        content: string
    ) {
        const lastChapter = await prisma.chapter.findFirst({
            where: { storyId, isLastChapter: true },
            orderBy: { position: 'desc' },
        })
        if (!lastChapter || lastChapter.id !== parentChapterId) {
            throw new BadRequestError('Нет доступной главы для продолжения')
        }

        const story = await prisma.story.findUnique({ where: { id: storyId } })
        if (!story)
            throw new NotFoundError(`История с ID ${storyId} не найдена`)
        if (story.currentPhase !== Phase.PROPOSAL)
            throw new BadRequestError(
                'Сейчас не фаза предложений для этой истории'
            )

        const proposal = await prisma.chapterProposal.create({
            data: { storyId, parentChapterId, authorId, title, content },
        })

        // После второго предложения запускаем таймер
        const count = await prisma.chapterProposal.count({ where: { storyId } })
        if (count >= 2) {
            const deadline = new Date(Date.now() + story.proposalTime)
            await prisma.story.update({
                where: { id: storyId },
                data: { proposalDeadline: deadline },
            })
            TimerService.setProposalTimer(storyId, story.proposalTime, () =>
                this.endProposals(storyId)
            )
        }

        return proposal
    },

    async deleteProposal(
        proposalId: string,
        authorId: string,
        storyId: string
    ) {
        const proposal = await prisma.chapterProposal.findUnique({
            where: { id: proposalId, storyId },
        })
        if (!proposal)
            throw new NotFoundError(`Предложение с ID ${proposalId} не найдено`)

        const story = await prisma.story.findUnique({
            where: { id: storyId },
        })

        if (!story) {
            throw new NotFoundError(`История с ID ${storyId} не найдена`)
        }

        if (story.currentPhase !== Phase.PROPOSAL) {
            throw new BadRequestError(
                'Сейчас не фаза предложений для этой истории'
            )
        }

        if (proposal.authorId !== authorId) {
            throw new ForbiddenError(
                'Вы не являетесь автором этого предложения'
            )
        }

        await prisma.chapterProposal.delete({
            where: { id: proposalId, storyId },
        })

        return { success: true }
    },

    async changeProposal(
        proposalId: string,
        authorId: string,
        storyId: string,
        title?: string,
        content?: string
    ) {
        const proposal = await prisma.chapterProposal.findUnique({
            where: { id: proposalId, storyId },
        })

        if (!proposal) {
            throw new NotFoundError(`Предложение с ID ${proposalId} не найдено`)
        }

        const story = await prisma.story.findUnique({
            where: { id: storyId },
        })

        if (!story) {
            throw new NotFoundError(`История с ID ${storyId} не найдена`)
        }

        if (story.currentPhase !== Phase.PROPOSAL) {
            throw new BadRequestError(
                'Сейчас не фаза предложений для этой истории'
            )
        }

        if (proposal.authorId !== authorId) {
            throw new ForbiddenError(
                'Вы не являетесь автором этого предложения'
            )
        }

        const proposalAfter = await prisma.chapterProposal.update({
            where: { id: proposalId, storyId },
            data: { title, content },
        })

        console.log(`Proposal ${proposalId} changed by user ${authorId}`)

        return proposalAfter
    },

    async selectWinnerProposal(proposalId: string, authorId: string) {
        const proposal = await prisma.chapterProposal.findUnique({
            where: { id: proposalId },
        })

        if (!proposal)
            throw new NotFoundError(`Предложение с ID ${proposalId} не найдено`)

        const collaborator = await prisma.storyCollaborator.findFirst({
            where: { storyId: proposal.storyId, userId: authorId },
        })

        if (!collaborator || collaborator.role !== 'ADMIN') {
            throw new ForbiddenError(
                'Вы не являетесь владельцем этой истории, выбора победителя невозможен'
            )
        }

        await prisma.story.update({
            where: { id: proposal.storyId },
            data: { currentPhase: Phase.PROPOSAL, votingDeadline: null },
        })

        await prisma.chapter.updateMany({
            where: { storyId: proposal.storyId, isLastChapter: true },
            data: { isLastChapter: false },
        })

        await chapterStoryService.createChapter(
            proposal.storyId,
            {
                title: proposal.title,
                content: proposal.content,
            },
            proposal.authorId
        )

        await collaboratorService.addCollaboratorInStory(
            proposal.storyId,
            proposal.authorId
        )

        await prisma.chapterProposal.deleteMany({
            where: { storyId: proposal.storyId },
        })
    },

    async voteProposal(proposalId: string, authorId: string) {
        const proposal = await prisma.chapterProposal.findUnique({
            where: { id: proposalId },
        })
        if (!proposal) {
            throw new NotFoundError(`Предложение с ID ${proposalId} не найдено`)
        }

        const story = await prisma.story.findUnique({
            where: { id: proposal.storyId },
        })

        const user = await prisma.vote.findFirst({
            where: { chapterProposalId: proposalId, authorId },
        })

        if (user)
            throw new ConflictError('Вы уже голосовали за это предложение')

        if (!story || story.currentPhase !== Phase.VOTING)
            throw new BadRequestError(
                'Сейчас не фаза голосования для этой истории'
            )

        await prisma.vote.create({
            data: { chapterProposalId: proposalId, authorId },
        })

        await prisma.chapterProposal.update({
            where: { id: proposalId },
            data: { voteCount: { increment: 1 } },
        })

        console.log(`User ${authorId} voted for proposal ${proposalId}`)

        return { success: true }
    },

    async deleteVoteProposal(proposalId: string, authorId: string) {
        const proposal = await prisma.chapterProposal.findUnique({
            where: { id: proposalId, authorId },
        })
        if (!proposal)
            throw new NotFoundError(`Предложение с ID ${proposalId} не найдено`)

        const story = await prisma.story.findUnique({
            where: { id: proposal.storyId },
        })

        const user = await prisma.vote.findFirst({
            where: { chapterProposalId: proposalId, authorId },
        })

        if (!user)
            throw new BadRequestError('Вы не голосовали за это предложение')

        if (!story || story.currentPhase !== Phase.VOTING)
            throw new BadRequestError('Не в фазе голосования')

        await prisma.vote.delete({
            where: { id: user.id },
        })

        await prisma.chapterProposal.update({
            where: { id: proposalId },
            data: { voteCount: { decrement: 1 } },
        })

        console.log(`User ${authorId} deleted vote for proposal ${proposalId}`)

        return { success: true }
    },

    async getProposals(storyId: string, parentChapterId: string) {
        const proposals = await prisma.chapterProposal.findMany({
            where: { storyId, parentChapterId },
            include: { votes: true },
        })
        return proposals
    },

    async getProposalById(id: string) {
        const proposal = await prisma.chapterProposal.findUnique({
            where: { id },
            include: { votes: true },
        })
        if (!proposal)
            throw new NotFoundError(`Предложение с ID ${id} не найдено`)

        return proposal
    },

    async getProposalsPaginated(
        storyId: string,
        parentChapterId: string,
        page: number = 1,
        pageSize: number = 10
    ) {
        const totalCount = await prisma.chapterProposal.count({
            where: { storyId, parentChapterId },
        })
        const items = await prisma.chapterProposal.findMany({
            where: { storyId, parentChapterId },
            orderBy: { createdAt: 'asc' },
            skip: (page - 1) * pageSize,
            take: pageSize,
        })
        const totalPages = Math.ceil(totalCount / pageSize) || 1

        const itemsWithHasWon = items.map((item) => ({
            ...item,
            hasWon: false,
        }))
        return {
            items: itemsWithHasWon,
            totalCount,
            totalPages,
            page,
            pageSize,
        }
    },

    async endProposals(storyId: string) {
        const story = await prisma.story.findUnique({
            where: { id: storyId },
        })

        if (!story) {
            throw new NotFoundError(`История с ID ${storyId} не найдена`)
        }

        const votingDeadline = new Date(Date.now() + story.votingTime)
        await prisma.story.update({
            where: { id: storyId },
            data: {
                currentPhase: Phase.VOTING,
                votingDeadline,
                proposalDeadline: null,
            },
        })

        TimerService.setVotingTimer(storyId, story.votingTime, () =>
            this.endVoting(storyId)
        )
    },

    async endVoting(storyId: string) {
        const proposals = await prisma.chapterProposal.findMany({
            where: { storyId },
        })

        if (proposals.length === 0) {
            await prisma.story.update({
                where: { id: storyId },
                data: { currentPhase: Phase.PROPOSAL, votingDeadline: null },
            })

            return
        }

        let winner
        const allCountVotes = proposals.reduce((acc, proposal) => {
            acc += proposal.voteCount
            return acc
        }, 0)

        if (allCountVotes === 0) {
            const randomIndex = Math.floor(Math.random() * proposals.length)
            winner = proposals[randomIndex]
        } else {
            winner = proposals.reduce((prev, cur) =>
                prev.voteCount > cur.voteCount ? prev : cur
            )
        }

        await prisma.story.update({
            where: { id: storyId },
            data: { currentPhase: Phase.PROPOSAL, votingDeadline: null },
        })

        await prisma.chapter.updateMany({
            where: { storyId, isLastChapter: true },
            data: { isLastChapter: false },
        })

        await chapterStoryService.createChapter(
            storyId,
            {
                title: winner.title,
                content: winner.content,
            },
            winner.authorId
        )

        await collaboratorService.addCollaboratorInStory(
            storyId,
            winner.authorId
        )

        await prisma.chapterProposal.deleteMany({ where: { storyId } })
    },
}
</file>

<file path="services/story-service/src/services/story.service.ts">
import { Prisma } from '@prisma/client'
import { ChangeStoryInput, CreateStoryInput } from '../model/story.model'
import { prisma, Role } from '../prisma'
import { BadRequestError, ForbiddenError, NotFoundError } from '../utils/errors'
import { TimerService } from './time.service'
import { proposalService } from './proposal.service'

export const storyService = {
    async createStory(data: CreateStoryInput, authorId: string) {
        try {
            const story = await prisma.story.create({
                data: {
                    title: data.title,
                    description: data.description,
                    coverImageUrl: data.coverImageUrl,
                    isPublic: data.isPublic ?? true,
                    proposalTime: data.proposalTime,
                    votingTime: data.votingTime,
                    authorId,
                    // создаем начальную главу
                    chapters: {
                        create: {
                            title: data.initialChapter.title,
                            content: data.initialChapter.content,
                            authorId,
                            position: 1,
                            isLastChapter: true,
                        },
                    },
                    genres: {
                        connect: data.genres.map((genre) => ({
                            id: genre,
                        })),
                    },
                    storyCollaborators: {
                        create: {
                            userId: authorId,
                            role: Role.ADMIN,
                        },
                    },
                },
                include: {
                    storyCollaborators: true,
                    genres: true,
                },
            })

            return {
                ...story,
                storyCollaborators: story.storyCollaborators.map(
                    (collaborator) => ({
                        id: collaborator.id,
                        userId: collaborator.userId,
                        role: collaborator.role,
                    })
                ),
            }
        } catch (error) {
            if (error.code === 'P2025') {
                throw new BadRequestError(
                    'Один или несколько указанных жанров не существуют'
                )
            }
            if (error.code === 'P2003') {
                throw new BadRequestError('Указан несуществующий автор')
            }
            throw error
        }
    },

    async getStoryById(id: string, userId?: string) {
        const story = await prisma.story.findUnique({
            where: { id },
            include: {
                storyCollaborators: true,
                genres: true,
            },
        })

        if (!story?.isPublic && story?.authorId !== userId) {
            throw new ForbiddenError(
                'У вас нет прав для просмотра этой истории'
            )
        }

        let result
        if (story) {
            result = await prisma.story.update({
                where: { id },
                data: {
                    viewCount: story.viewCount + 1,
                },
                include: {
                    storyCollaborators: true,
                    genres: true,
                },
            })
        } else {
            throw new NotFoundError(`Story not found by ${id}`)
        }

        if (!result) return null

        return result
    },

    async getMyStoriesPaginated(
        userId: string,
        page: number = 1,
        pageSize: number = 10
    ) {
        const totalCount = await prisma.story.count({
            where: {
                storyCollaborators: {
                    some: {
                        userId,
                    },
                },
            },
        })

        const items = await prisma.story.findMany({
            where: {
                storyCollaborators: {
                    some: {
                        userId,
                    },
                },
            },
            orderBy: { updatedAt: 'desc' },
            skip: (page - 1) * pageSize,
            take: pageSize,
            include: { storyCollaborators: true, genres: true },
        })

        const totalPages = Math.ceil(totalCount / pageSize) || 1
        return { items, totalCount, totalPages, page, pageSize }
    },

    async updateStory(
        id: string,
        // Добавляем proposalDeadline в тип данных, чтобы пользователь не смог его указать, но при этом правильно работала типизация
        data: Partial<ChangeStoryInput> & {
            proposalDeadline?: Date
            votingDeadline?: Date
        },
        userId: string
    ) {
        const story = await prisma.story.findUnique({
            where: { id },
            include: {
                storyCollaborators: true,
                genres: true,
            },
        })

        if (!story) {
            throw new NotFoundError(`Story not found by ${id}`)
        }

        const userRole = story.storyCollaborators.find(
            (c) => c.userId === userId
        )?.role

        if (!userRole || userRole !== 'ADMIN') {
            throw new ForbiddenError(
                'У вас нет прав для изменения этой истории'
            )
        }

        if (
            data.proposalTime !== undefined &&
            story.proposalTime !== data.proposalTime &&
            story.currentPhase === 'PROPOSAL' &&
            story.proposalDeadline
        ) {
            TimerService.clearProposalTimer(id)

            const now = new Date()
            const deadline = story.proposalDeadline
            const elapsedTime =
                now.getTime() - (deadline.getTime() - story.proposalTime)
            const remainingTime = Math.max(
                data.proposalTime - elapsedTime,
                1000
            )

            const newDeadline = new Date(now.getTime() + remainingTime)
            data['proposalDeadline'] = newDeadline

            TimerService.setProposalTimer(id, remainingTime, () =>
                proposalService.endProposals(id)
            )
        }

        if (
            data.votingTime !== undefined &&
            story.votingTime !== data.votingTime &&
            story.currentPhase === 'VOTING' &&
            story.votingDeadline
        ) {
            TimerService.clearVotingTimer(id)

            const now = new Date()
            const deadline = story.votingDeadline
            const elapsedTime =
                now.getTime() - (deadline.getTime() - story.votingTime)
            const remainingTime = Math.max(data.votingTime - elapsedTime, 1000)

            const newDeadline = new Date(now.getTime() + remainingTime)
            data['votingDeadline'] = newDeadline

            TimerService.setVotingTimer(id, remainingTime, () =>
                proposalService.endVoting(id)
            )
        }

        try {
            const updateStory = await prisma.story.update({
                where: { id },
                data: {
                    ...data,
                    genres: data.genres && {
                        set: [],
                        connect: data.genres.map((genre) => ({ id: genre })),
                    },
                },
                include: {
                    storyCollaborators: true,
                    genres: true,
                },
            })

            return updateStory
        } catch (error) {
            if (error.code === 'P2025') {
                throw new BadRequestError(
                    'Один или несколько указанных жанров не существуют'
                )
            }
        }
    },

    async deleteStory(id: string, userId: string) {
        const story = await prisma.story.findUnique({
            where: { id },
            include: {
                storyCollaborators: true,
            },
        })

        if (!story) {
            throw new NotFoundError(`Story not found by ${id}`)
        }

        const userRole = story.storyCollaborators.find(
            (c) => c.userId === userId
        )?.role

        if (!userRole || userRole !== 'ADMIN') {
            throw new ForbiddenError('У вас нет прав для удаления этой истории')
        }

        await prisma.story.delete({
            where: { id },
        })

        TimerService.clearAllTimers(id)

        return { success: true }
    },

    async getStoriesPaginated(
        page: number = 1,
        pageSize: number = 10,
        userId: string | undefined
    ) {
        const obj: Prisma.StoryFindManyArgs = {
            where: {
                OR: [{ isPublic: true }],
            },
            orderBy: { updatedAt: 'desc' as Prisma.SortOrder },
            skip: (page - 1) * pageSize,
            take: pageSize,
            include: { storyCollaborators: true, genres: true },
        }

        if (userId) {
            obj.where?.OR?.push({ storyCollaborators: { some: { userId } } })
        }

        console.log(obj.where?.OR)

        const totalCount = await prisma.story.count({
            where: obj.where,
        })

        const items = await prisma.story.findMany(obj)

        const totalPages = Math.ceil(totalCount / pageSize) || 1
        return { items, totalCount, totalPages, page, pageSize }
    },
}
</file>

<file path="services/user-profile-service/app/main.go">
package main

import (
	"log"
	"os"
	"github.com/monst/story-craft/services/user-profile-service/router"
	"github.com/monst/story-craft/services/user-profile-service/utils"
)

func main() {
	// Инициализация базы данных
	db, err := utils.SetupDatabase()
	if err != nil {
		log.Fatalf("Не удалось подключиться к базе данных: %v", err)
	}

	// Закрытие соединения с БД после завершения работы программы
	sqlDB, err := db.DB()
	if err != nil {
		log.Fatalf("Не удалось получить экземпляр *sql.DB: %v", err)
	}
	defer sqlDB.Close()

	// Инициализация роутера
	r := router.SetupRouter(db)

	// Запуск сервера на порту из env или 8080 по умолчанию
	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}
	if err := r.Run(":" + port); err != nil {
		log.Fatalf("Не удалось запустить сервер: %v", err)
	}
}
</file>

<file path="services/user-profile-service/utils/database.go">
package utils

import (
	"fmt"
	"log"
	"os"
	"github.com/monst/story-craft/services/user-profile-service/models"

	"github.com/joho/godotenv"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"
)

func SetupDatabase() (*gorm.DB, error) {
	if err := godotenv.Load(); err != nil {
		log.Println("Не удалось загрузить файл .env, используем переменные окружения системы")
	}
	dsn := fmt.Sprintf("host=%s user=%s password=%s dbname=%s port=%s", os.Getenv("DB_HOST"), os.Getenv("DB_USER"), os.Getenv("DB_PASSWORD"), os.Getenv("DB_NAME"), os.Getenv("DB_PORT"))
	db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})
	if err != nil {
		return nil, err
	}

	// enable uuid extension for generating UUIDs
	if err := db.Exec(`CREATE EXTENSION IF NOT EXISTS "uuid-ossp";`).Error; err != nil {
		return nil, err
	}

	// Миграция схемы
	if err := db.AutoMigrate(&models.Profile{}); err != nil {
		return nil, err
	}

	return db, nil
}
</file>

<file path="start-prod.bat">
if not exist .env (
  copy .env.example .env
)
docker compose -f docker-compose.db.yml -f docker-compose.prod.yml up --build -d
</file>

<file path="start-prod.sh">
#!/bin/bash

if [ ! -f .env ]; then
  echo "Creating .env file from .env.example"
  cp .env.example .env
fi

docker compose -f docker-compose.db.yml -f docker-compose.prod.yml up --build -d
</file>

<file path=".env.example">
# Общие настройки
JWT_SECRET=your_secure_secret_here
JWT_ACCESS_EXPIRES=3600
JWT_REFRESH_EXPIRES=604800

# Настройки PostgreSQL
POSTGRES_DB=postgres
DB_USER=storycraft_user
DB_NAME=storycraft_db
DB_PASSWORD=secret

# Настройки сервисов
API_GATEWAY_PORT=3000
AUTH_SERVICE_PORT=3001
STORY_SERVICE_PORT=3002
USER_SERVICE_PORT=3003
MEDIA_SERVICE_PORT=3004
SOCIAL_SERVICE_PORT=3005
NOTIFICATION_SERVICE_PORT=3006
</file>

<file path="init-databases.sh">
#!/bin/bash
set -e

# Используем стандартные переменные окружения, предоставляемые образом postgres
# POSTGRES_USER будет содержать значение ${DB_USER} из вашего .env
# POSTGRES_PASSWORD будет содержать значение ${DB_PASSWORD} из вашего .env
# POSTGRES_DB будет содержать значение ${POSTGRES_DB} из вашего .env

# Функция для создания базы данных, если она не существует
create_db() {
  local db_name=$1
  local owner=$POSTGRES_USER # Используем пользователя, созданного entrypoint'ом

  echo "Checking database $db_name"
  
  # Подключаемся к базе данных по умолчанию ($POSTGRES_DB) для проверки
  db_exists=$(psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname "$POSTGRES_DB" -tAc "SELECT 1 FROM pg_database WHERE datname='$db_name'")
  
  if [ -z "$db_exists" ]; then
    echo "Creating database $db_name owned by $owner"
    # Подключаемся к базе данных по умолчанию ($POSTGRES_DB) для создания новой БД
    psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname "$POSTGRES_DB" -c "CREATE DATABASE $db_name OWNER $owner;"
    echo "Database $db_name created"
    
    # Предоставляем все права владельцу (подключаемся к созданной БД)
    psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname "$db_name" -c "GRANT ALL PRIVILEGES ON DATABASE $db_name TO $owner;"
    echo "Granted permissions on $db_name to $owner"

    # Дополнительные права на схему public (подключаемся к созданной БД)
    psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname "$db_name" -c "GRANT ALL ON SCHEMA public TO $owner;"
    psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname "$db_name" -c "ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO $owner;"
    echo "Granted permissions on schema public in $db_name to $owner"
  else
    echo "Database $db_name already exists"
  fi
}

# Создаем только те базы данных, которые нужны сервисам
create_db "storycraft_auth"
create_db "storycraft_story"
create_db "storycraft_user" 
create_db "$DB_NAME"

echo "Database initialization script finished for user $POSTGRES_USER."
</file>

<file path="services/api-gateway/Dockerfile.prod">
FROM node:20-slim AS builder

WORKDIR /app

RUN apt-get update -y && apt-get install -y openssl

COPY package*.json ./
RUN npm install

COPY tsconfig.json ./
COPY src ./src

RUN npm run build

FROM node:20-slim

WORKDIR /app

COPY package*.json ./
RUN npm install --production

COPY --from=builder /app/dist ./dist

CMD ["/bin/sh", "-c", "npm run start"]
</file>

<file path="services/api-gateway/src/plugins/proxy.ts">
import fastifyPlugin from 'fastify-plugin'
import httpProxy from '@fastify/http-proxy'
import { serviceConfig, commonProxyOptions } from '../config'
import { FastifyInstance } from 'fastify'
import { TokenPayload } from 'storycraft-common-types'

export default fastifyPlugin(async (fastify: FastifyInstance) => {
    // Добавляем заголовок x-user-object в запросы к проксируемым сервисам для аутентификации

    fastify.addHook('onRequest', async (request, reply) => {
        try {
            if (request.headers.authorization) {
                const token = request.headers.authorization.split(' ')[1]
                const res = (await fastify.jwt.decode(token)) as TokenPayload

                if (res) {
                    request.headers['x-user-object'] = JSON.stringify(res)
                }
            }
        } catch (err) {
            fastify.log.error(`Error decoding token: ${err.message}`)
        }
    })

    for (const [serviceName, config] of Object.entries(serviceConfig)) {
        fastify.log.info(
            `Setting up proxy for ${serviceName} at ${config.prefix} -> ${config.upstream}`
        )

        await fastify.register(httpProxy, {
            upstream: config.upstream,
            prefix: config.prefix,
            ...commonProxyOptions,
        })
    }
})
</file>

<file path="services/auth-service/src/server.ts">
import express from 'express'
import morgan from 'morgan'
// import helmet from 'helmet'
// import cors from 'cors'
// import compression from 'compression'
import methodOverride from 'method-override'
import 'dotenv/config'
import config from './config'
import routes from './routes'
import { errorHandler } from './middlewares'

class ExpressServer {
    public app: express.Application

    constructor() {
        this.app = express()
        this.config()
        this.routes()
    }

    public config() {
        this.app.use(express.json())
        this.app.use(express.urlencoded({ extended: true }))
        this.app.use(morgan(config.nodeEnv === 'dev' ? 'dev' : 'combined'))
        // this.app.use(helmet())
        // this.app.use(cors())
        // this.app.use(compression())
        this.app.use(methodOverride())
    }

    public routes() {
        this.app.use('/', routes)

        this.app.use('*', (req, res) => {
            res.status(404).json({ message: 'Route not found' })
        })

        // ??? Typescript почему-то не понимает, что это middleware express для обработки ошибок
        this.app.use(errorHandler as any as express.ErrorRequestHandler)
    }
}

export default ExpressServer
</file>

<file path="services/auth-service/src/services/auth.service.ts">
import { prisma } from '../lib/prisma'
import {
    hashPassword,
    comparePassword,
    createAccessToken,
    createRefreshToken,
    revokeRefreshToken,
    verifyRefreshToken,
} from '../lib/auth'
import {
    BadRequestError,
    ConflictError,
    NotFoundError,
    UnauthorizedError,
    InternalServerError,
} from '../utils/errors'
import { AppError } from '../utils/errors'
import { Prisma } from '@prisma/client'

export class AuthService {
    async register(userData: {
        email: string
        password: string
        username: string
        avatarUrl?: string
    }) {
        const { email, password, username, avatarUrl } = userData

        try {
            const existingUser = await prisma.user.findFirst({
                where: {
                    OR: [{ email }, { username }],
                },
            })

            if (existingUser) {
                throw new ConflictError(
                    'User with this email or username already exists'
                )
            }

            const hashedPassword = await hashPassword(password)
            if (!hashedPassword) {
                throw new InternalServerError('Failed to hash password')
            }

            const user = await prisma.user.create({
                data: {
                    email,
                    username,
                    avatarUrl: avatarUrl,
                    password: hashedPassword,
                },
            })

            const accessToken = createAccessToken({
                userId: user.id,
            })

            const refreshToken = await createRefreshToken(user.id)

            return {
                user: {
                    id: user.id,
                    email: user.email,
                    username: user.username,
                    role: user.role,
                },
                tokens: {
                    accessToken,
                    refreshToken,
                },
            }
        } catch (error) {
            if (error instanceof AppError) {
                throw error
            }

            if (error instanceof Prisma.PrismaClientKnownRequestError) {
                if (error.code === 'P2002') {
                    throw new ConflictError(
                        'User with this information already exists'
                    )
                }
            }

            console.error('Registration error:', error)
            throw new InternalServerError('Failed to register user')
        }
    }

    async login(credentials: { email: string; password: string }) {
        const { email, password } = credentials

        try {
            const user = await prisma.user.findUnique({
                where: { email },
            })

            if (!user) {
                throw new UnauthorizedError('Invalid email or password')
            }

            const isPasswordValid = await comparePassword(
                password,
                user.password
            )
            if (!isPasswordValid) {
                throw new UnauthorizedError('Invalid email or password')
            }

            const accessToken = createAccessToken({
                userId: user.id,
            })

            const refreshToken = await createRefreshToken(user.id)

            return {
                user: {
                    id: user.id,
                    email: user.email,
                    username: user.username,
                    role: user.role,
                },
                tokens: {
                    accessToken,
                    refreshToken,
                },
            }
        } catch (error) {
            if (error instanceof AppError) {
                throw error
            }
            console.error('Login error:', error)
            throw new InternalServerError('Failed to log in')
        }
    }

    async logout(token: string) {
        try {
            if (!token) {
                throw new BadRequestError('Refresh token is required')
            }

            const tokenRecord = await prisma.refreshToken.findUnique({
                where: { token },
            })

            if (!tokenRecord) {
                throw new NotFoundError('Refresh token not found')
            }

            await revokeRefreshToken(token)
            return { success: true }
        } catch (error) {
            if (error instanceof AppError) {
                throw error
            }
            console.error('Logout error:', error)
            throw new InternalServerError('Failed to log out')
        }
    }

    async refreshTokens(token: string) {
        try {
            if (!token) {
                throw new BadRequestError('Refresh token is required')
            }

            const payload = await verifyRefreshToken(token)

            if (!payload) {
                throw new UnauthorizedError('Invalid or expired refresh token')
            }

            await revokeRefreshToken(token, 'Token refreshed')

            const user = await prisma.user.findUnique({
                where: { id: payload.userId },
            })

            if (!user) {
                throw new NotFoundError('User not found')
            }

            const accessToken = createAccessToken({
                userId: user.id,
            })

            const refreshToken = await createRefreshToken(user.id)

            return {
                tokens: {
                    accessToken,
                    refreshToken,
                },
            }
        } catch (error) {
            if (error instanceof AppError) {
                throw error
            }
            console.error('Token refresh error:', error)
            throw new InternalServerError('Failed to refresh tokens')
        }
    }
}

export default new AuthService()
</file>

<file path="services/user-profile-service/go.mod">
module github.com/monst/story-craft/services/user-profile-service

go 1.23.1

require (
	github.com/bytedance/sonic v1.12.9 // indirect
	github.com/bytedance/sonic/loader v0.2.3 // indirect
	github.com/cloudwego/base64x v0.1.5 // indirect
	github.com/cloudwego/iasm v0.2.0 // indirect
	github.com/gabriel-vasile/mimetype v1.4.8 // indirect
	github.com/gin-contrib/sse v1.0.0 // indirect
	github.com/gin-gonic/gin v1.10.0 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/go-playground/validator/v10 v10.25.0 // indirect
	github.com/goccy/go-json v0.10.5 // indirect
	github.com/google/uuid v1.6.0 // indirect
	github.com/jackc/pgpassfile v1.0.0 // indirect
	github.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761 // indirect
	github.com/jackc/pgx/v5 v5.7.2 // indirect
	github.com/jackc/puddle/v2 v2.2.2 // indirect
	github.com/jinzhu/inflection v1.0.0 // indirect
	github.com/jinzhu/now v1.1.5 // indirect
	github.com/joho/godotenv v1.5.1 // indirect
	github.com/json-iterator/go v1.1.12 // indirect
	github.com/klauspost/cpuid/v2 v2.2.10 // indirect
	github.com/leodido/go-urn v1.4.0 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
	github.com/modern-go/reflect2 v1.0.2 // indirect
	github.com/pelletier/go-toml/v2 v2.2.3 // indirect
	github.com/twitchyliquid64/golang-asm v0.15.1 // indirect
	github.com/ugorji/go/codec v1.2.12 // indirect
	golang.org/x/arch v0.14.0 // indirect
	golang.org/x/crypto v0.35.0 // indirect
	golang.org/x/net v0.35.0 // indirect
	golang.org/x/sync v0.11.0 // indirect
	golang.org/x/sys v0.30.0 // indirect
	golang.org/x/text v0.22.0 // indirect
	google.golang.org/protobuf v1.36.5 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
	gorm.io/driver/postgres v1.5.11 // indirect
	gorm.io/gorm v1.25.12 // indirect
)
</file>

<file path="start-dev.bat">
if not exist .env (
  copy .env.example .env
)

docker compose -f docker-compose.db.yml -f docker-compose.dev.yml up --watch --build
</file>

<file path="start-dev.sh">
#!/bin/bash

if [ ! -f .env ]; then
  echo "Creating .env file from .env.example"
  cp .env.example .env
fi

set -a # Automatically export all variables
source .env
set +a
echo "API_GATEWAY_PORT in script: ${API_GATEWAY_PORT}" # Добавлено для проверки
echo "Running docker compose..."

docker compose -f docker-compose.db.yml -f docker-compose.dev.yml up --build
</file>

<file path="docker-compose.db.yml">
version: '3.8'

services:
  postgres:
    image: postgres:16-alpine
    environment:
      POSTGRES_DB: ${POSTGRES_DB}
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    volumes:
      - ./init-databases.sh:/docker-entrypoint-initdb.d/init-databases.sh
      - postgres-data:/var/lib/postgresql/data
    ports:
      - 5435:5432
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER}"]
      interval: 5s
      timeout: 5s
      retries: 5
    env_file:
      - .env
    networks:
      - backend

volumes:
  postgres-data:
</file>

<file path="services/api-gateway/package.json">
{
    "name": "api-gateway",
    "version": "1.0.0",
    "main": "app.js",
    "scripts": {
        "test": "node --test test/**/*.test.js",
        "build": "tsc",
        "start": "node dist/app.js",
        "dev": "nodemon -L --exec tsx src/app.ts"
    },
    "author": "",
    "license": "ISC",
    "description": "This project was bootstrapped with Fastify-CLI.",
    "dependencies": {
        "@fastify/autoload": "^6.2.0",
        "@fastify/compress": "^8.0.1",
        "@fastify/cors": "^11.0.1",
        "@fastify/helmet": "^13.0.1",
        "@fastify/http-proxy": "^11.1.2",
        "@fastify/jwt": "^9.1.0",
        "@fastify/sensible": "^6.0.3",
        "@fastify/swagger": "^9.5.0",
        "@fastify/swagger-ui": "^5.2.2",
        "@types/node": "^22.13.11",
        "close-with-grace": "^2.2.0",
        "eslint": "^9.23.0",
        "fastify": "^5.2.1",
        "fastify-cli": "^7.3.0",
        "fastify-plugin": "^5.0.1",
        "nodemon": "^3.1.9",
        "pino-pretty": "^13.0.0",
        "storycraft-common-types": "^1.0.1",
        "tsx": "^4.19.3",
        "typescript": "^5.8.2",
        "typescript-eslint": "^8.27.0",
        "zod": "^3.24.2"
    },
    "directories": {
        "test": "test"
    },
    "keywords": []
}
</file>

<file path="services/api-gateway/src/app.ts">
import fastify from 'fastify'
import plugins from './plugins'
import { env } from './config'
import closeWithGrace from 'close-with-grace'
import jwt from '@fastify/jwt'
import fastifyCors from '@fastify/cors'
import fastifyHelmet from '@fastify/helmet'
import fastifyCompress from '@fastify/compress'

const settingsFastify = {
    logger: {
        level: env.LOG_LEVEL,
        ...(env.NODE_ENV === 'dev' && {
            transport: {
                target: 'pino-pretty',
            },
        }),
    },
    trustProxy: true,
}

const app = fastify(settingsFastify)

const start = async () => {
    try {
        await app.register(fastifyCors)
        await app.register(fastifyHelmet)
        await app.register(fastifyCompress)

        await app.register(jwt, {
            secret: env.JWT_SECRET,
        })
        await app.register(plugins.swagger)
        await app.register(plugins.sensible)
        await app.register(plugins.proxy)

        app.get('/health', async () => {
            return {
                status: 'ok',
                timestamp: new Date().toISOString(),
                environment: env.NODE_ENV,
            }
        })

        app.setNotFoundHandler((request, reply) => {
            reply.status(404).send({
                statusCode: 404,
                error: 'Not Found',
                message: `Route ${request.method}:${request.url} not found`,
            })
        })

        await app.listen({ port: env.PORT, host: env.HOST })
        app.log.info(
            `API Gateway server running at ${env.HOST}:${env.PORT} in ${env.NODE_ENV} mode`
        )
    } catch (err) {
        app.log.error(err)
        process.exit(1)
    }
}

closeWithGrace(async ({ signal, err, manual }) => {
    if (err) {
        app.log.error(err)
    }
    app.log.info(`Closing app with ${signal}`)
    await app.close()
    if (manual) {
        process.exit(0)
    }
})

start()
</file>

<file path="services/auth-service/package.json">
{
    "name": "auth-service",
    "version": "1.0.0",
    "main": "index.js",
    "scripts": {
        "test": "echo \"Error: no test specified\" && exit 1",
        "dev": "nodemon -L --exec tsx src/index.ts",
        "build": "tsc",
        "start": "node dist/index.js"
    },
    "author": "",
    "license": "ISC",
    "description": "",
    "devDependencies": {
        "@eslint/js": "^9.22.0",
        "eslint": "^9.22.0",
        "globals": "^16.0.0",
        "nodemon": "^3.1.9",
        "typescript": "^5.8.2",
        "typescript-eslint": "^8.26.0"
    },
    "dependencies": {
        "@prisma/client": "^6.4.1",
        "@types/bcrypt": "^5.0.2",
        "@types/body-parser": "^1.19.5",
        "@types/compression": "^1.7.5",
        "@types/cors": "^2.8.17",
        "@types/express": "^5.0.0",
        "@types/express-validator": "^2.20.33",
        "@types/jsonwebtoken": "^9.0.9",
        "@types/method-override": "^3.0.0",
        "@types/morgan": "^1.9.9",
        "@types/node": "^22.13.10",
        "@types/uuid": "^10.0.0",
        "bcrypt": "^5.1.1",
        "bcryptjs": "^3.0.2",
        "body-parser": "^1.20.3",
        "compression": "^1.8.0",
        "cors": "^2.8.5",
        "dotenv": "^16.4.7",
        "express": "^4.21.2",
        "express-validator": "^7.2.1",
        "helmet": "^8.0.0",
        "jsonwebtoken": "^9.0.2",
        "method-override": "^3.0.0",
        "morgan": "^1.10.0",
        "prisma": "^6.4.1",
        "storycraft-common-types": "^1.0.1",
        "swagger-jsdoc": "^6.2.8",
        "swagger-ui-express": "^5.0.1",
        "tsx": "^4.19.3",
        "uuid": "^11.1.0",
        "zod": "^3.24.2"
    }
}
</file>

<file path="services/user-profile-service/handlers/profile_handler.go">
package handlers

import (
	"encoding/json"
	"net/http"
	"strings"
	"github.com/monst/story-craft/services/user-profile-service/models"

	"github.com/gin-gonic/gin"
	"gorm.io/gorm"
)

type ProfileHandler struct {
	db *gorm.DB
}

func NewProfileHandler(db *gorm.DB) *ProfileHandler {
	return &ProfileHandler{db: db}
}

// Создание нового профиля
func (h ProfileHandler) CreateProfile(c *gin.Context) {
	var input models.InputProfile

	requestUser := c.Request.Header.Get("x-user-object")
	if err := json.Unmarshal([]byte(requestUser), &input); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Ошибка в формате JSON: проверьте правильность данных"})
		return
	}

	if input.Username == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Ошибка: не передали username"})
	}

	// Проверка на существование пользователя с таким username
	var existingProfile models.Profile
	if err := h.db.Where("username = ?", input.Username).First(&existingProfile).Error; err == nil {
		c.JSON(http.StatusConflict, gin.H{"error": "Пользователь с таким username уже существует"})
		return
	} else if err != gorm.ErrRecordNotFound {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Ошибка при проверке существующих пользователей"})
		return
	}

	profile := models.Profile{
		UserID:    input.UserID,
		Username:  input.Username,
		Email:     input.Email,
		AvatarURL: input.AvatarURL,
		Role:      input.Role,
	}

	if err := h.db.Create(&profile).Error; err != nil {
		if strings.Contains(err.Error(), "unique constraint") {
			c.JSON(http.StatusConflict, gin.H{"error": "Пользователь с такими данными уже существует"})
		} else {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Не удалось создать профиль пользователя"})
		}
		return
	}

	c.JSON(http.StatusCreated, input)
}

// Получение профиля по user_id
func (h ProfileHandler) GetProfile(c *gin.Context) {
	var input models.InputProfile

	requestUser := c.Request.Header.Get("x-user-object")
	if err := json.Unmarshal([]byte(requestUser), &input); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Ошибка в формате JSON: проверьте правильность данных"})
		return
	}

	if input.Username == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Ошибка: не передали username"})
	}

	var profile models.Profile
	if err := h.db.Where("username = ?", input.Username).First(&profile).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			c.JSON(http.StatusNotFound, gin.H{"error": "Профиль не найден"})
		} else {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Ошибка при получении данных профиля"})
		}
		return
	}

	c.JSON(http.StatusOK, profile)
}

// Обновление профиля
func (h ProfileHandler) UpdateProfile(c *gin.Context) {
	var input models.InputProfile

	requestUser := c.Request.Header.Get("x-user-object")
	if err := json.Unmarshal([]byte(requestUser), &input); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Ошибка в формате JSON: проверьте правильность данных"})
		return
	}

	if input.Username == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Ошибка: не передали username"})
	}

	var profile models.Profile
	if err := h.db.Where("username = ?", input.Username).First(&profile).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			c.JSON(http.StatusNotFound, gin.H{"error": "Профиль не найден"})
		} else {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Ошибка при поиске профиля"})
		}
		return
	}

	if err := h.db.Model(&profile).Updates(input).Error; err != nil {
		if strings.Contains(err.Error(), "unique constraint") {
			c.JSON(http.StatusConflict, gin.H{"error": "Нарушение уникальности данных при обновлении"})
		} else {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Ошибка при обновлении профиля"})
		}
		return
	}

	// Получаем обновленный профиль
	if err := h.db.Where("username = ?", input.Username).First(&profile).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Профиль успешно обновлен, но возникла ошибка при получении обновленных данных"})
		return
	}

	c.JSON(http.StatusOK, profile)
}

// Удаление профиля
func (h ProfileHandler) DeleteProfile(c *gin.Context) {
	var input models.InputProfile

	requestUser := c.Request.Header.Get("x-user-object")
	if err := json.Unmarshal([]byte(requestUser), &input); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Ошибка в формате JSON: проверьте правильность данных"})
		return
	}

	if input.Username == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Ошибка: не передали username"})
	}

	// Проверка существования профиля перед удалением
	var profile models.Profile
	if err := h.db.Where("username = ?", input.Username).First(&profile).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			c.JSON(http.StatusNotFound, gin.H{"error": "Профиль для удаления не найден"})
		} else {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Ошибка при поиске профиля для удаления"})
		}
		return
	}

	if err := h.db.Delete(&profile).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Ошибка при удалении профиля"})
		return
	}

	c.JSON(http.StatusNoContent, nil)
}
</file>

<file path="services/auth-service/Dockerfile.dev">
FROM node:20-slim

WORKDIR /app

RUN apt-get update -y && apt-get install -y openssl curl wget

COPY package*.json ./
RUN npm install

COPY . .

RUN npx prisma generate

CMD ["/bin/sh", "-c", "npm install && npx prisma migrate dev && npm run dev"]
</file>

<file path="services/auth-service/Dockerfile.prod">
FROM node:20-slim AS builder

WORKDIR /app

COPY package.json package-lock.json ./
RUN npm ci

COPY . .

RUN npx prisma generate
RUN npm run build

FROM node:20-slim AS production

WORKDIR /app

COPY package.json package-lock.json ./
RUN npm ci --production

COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules

COPY --from=builder /app/prisma ./prisma

CMD ["/bin/sh", "-c", "npx prisma migrate deploy && npm run start"]
</file>

<file path="services/auth-service/src/routes/auth.routes.ts">
import { Router } from 'express'
import z from 'zod'
import { validateRequest, protectRoute } from '../middlewares'
import authService from '../services/auth.service'
import { Request, Response, NextFunction } from 'express'

const router = Router()

const loginSchema = z.object({
    email: z.string().email('Invalid email address'),
    password: z.string().min(6, 'Password must be at least 6 characters long'),
})

const registerSchema = z.object({
    email: z.string().email('Invalid email address'),
    password: z.string().min(6, 'Password must be at least 6 characters long'),
    username: z.string().min(2, 'Username must be at least 2 characters long'),
})

const refreshTokenSchema = z.object({
    refreshToken: z.string().nonempty('Refresh token is required'),
})

/**
 * @swagger
 * /register:
 *   post:
 *     summary: Регистрация нового пользователя
 *     tags: [Auth]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - email
 *               - password
 *               - username
 *             properties:
 *               email:
 *                 type: string
 *                 format: email
 *               password:
 *                 type: string
 *                 minLength: 6
 *               username:
 *                 type: string
 *                 minLength: 3
 *               fullName:
 *                 type: string
 *               avatarUrl:
 *                 type: string
 *     responses:
 *       201:
 *         description: Пользователь успешно зарегистрирован
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 user:
 *                   type: object
 *                   properties:
 *                     id:
 *                       type: string
 *                       format: uuid
 *                     email:
 *                       type: string
 *                     username:
 *                       type: string
 *                     fullName:
 *                       type: string
 *                     avatarUrl:
 *                       type: string
 *                     createdAt:
 *                       type: string
 *                       format: date-time
 *                 token:
 *                   type: string
 *       400:
 *         description: Некорректные данные для регистрации
 *       409:
 *         description: Пользователь с таким email или username уже существует
 */
router.post(
    '/register',
    validateRequest(registerSchema),
    async (req: Request, res: Response, next: NextFunction) => {
        try {
            const { email, password, username, avatarUrl } = req.body
            const result = await authService.register({
                email,
                password,
                username,
                avatarUrl,
            })

            res.status(201).json({
                message: 'User registered successfully',
                ...result,
            })
        } catch (error) {
            next(error)
        }
    }
)

/**
 * @swagger
 * /login:
 *   post:
 *     summary: Авторизация пользователя
 *     tags: [Auth]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - email
 *               - password
 *             properties:
 *               email:
 *                 type: string
 *                 format: email
 *               password:
 *                 type: string
 *     responses:
 *       200:
 *         description: Пользователь успешно авторизован
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 user:
 *                   type: object
 *                   properties:
 *                     id:
 *                       type: string
 *                       format: uuid
 *                     email:
 *                       type: string
 *                     username:
 *                       type: string
 *                     fullName:
 *                       type: string
 *                     avatarUrl:
 *                       type: string
 *                     createdAt:
 *                       type: string
 *                       format: date-time
 *                 token:
 *                   type: string
 *       400:
 *         description: Некорректные данные для авторизации
 *       401:
 *         description: Неверные учетные данные
 */
router.post(
    '/login',
    validateRequest(loginSchema),
    async (req: Request, res: Response, next: NextFunction) => {
        try {
            const { email, password } = req.body
            const result = await authService.login({ email, password })

            res.status(200).json({
                message: 'Login successful',
                ...result,
            })
        } catch (error) {
            next(error)
        }
    }
)

router.get('/is-auth', protectRoute, (req: Request, res: Response) => {
    res.status(200).json({ message: 'Authenticated', user: req.user })
})

/**
 * @swagger
 * /logout:
 *   post:
 *     summary: Выход пользователя
 *     tags: [Auth]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - refreshToken
 *             properties:
 *               refreshToken:
 *                 type: string
 *     responses:
 *       200:
 *         description: Успешный выход
 */
router.post(
    '/logout',
    protectRoute,
    validateRequest(refreshTokenSchema),
    async (req: Request, res: Response, next: NextFunction) => {
        try {
            const { refreshToken } = req.body
            await authService.logout(refreshToken)

            res.status(200).json({ message: 'Logout successful' })
        } catch (error) {
            next(error)
        }
    }
)

/**
 * @swagger
 * /refresh:
 *   post:
 *     summary: Обновление токенов
 *     tags: [Auth]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - refreshToken
 *             properties:
 *               refreshToken:
 *                 type: string
 *     responses:
 *       200:
 *         description: Токены успешно обновлены
 */
router.post(
    '/refresh',
    validateRequest(refreshTokenSchema),
    async (req: Request, res: Response, next: NextFunction) => {
        try {
            const { refreshToken } = req.body
            const result = await authService.refreshTokens(refreshToken)

            res.status(200).json({
                message: 'Token refreshed',
                ...result,
            })
        } catch (error) {
            next(error)
        }
    }
)

export default router
</file>

<file path="services/auth-service/src/routes/index.ts">
import { Router } from 'express'
import authRoutes from './auth.routes'
import swaggerJSDoc from 'swagger-jsdoc'
import config from '../config'

const router = Router()

const swaggerOptions = {
    definition: {
        openapi: '3.0.0',
        info: {
            title: 'Auth Service API',
            description: 'API документация для Auth Service',
            version: '1.0.0',
        },
    },
    apis: ['./src/routes/*.ts'], // Путь к роутам с JSDoc комментариями
}

const swaggerSpec = swaggerJSDoc(swaggerOptions)

router.use('/', authRoutes)

router.get('/health', (req, res) => {
    res.status(200).json({
        status: 'ok',
        service: 'auth-service',
        timestamp: new Date().toISOString(),
    })
})

router.get('/schema', (req, res) => {
    res.json(swaggerSpec)
})

export default router
</file>

<file path="docker-compose.dev.yml">
version: '3.8'
# !!! Сервисы называем с суффиксом -dev
# !!! Для внутренних сервисов добавляем сеть backend
networks:
  frontend:
  backend:
    internal: true
services:
  api-gateway-dev:
    build:
      context: ./services/api-gateway
      dockerfile: Dockerfile.dev
    # volumes:
    #   - ./services/api-gateway:/app
    #   - /app/node_modules
    ports:
      - "${API_GATEWAY_PORT}:${API_GATEWAY_PORT}"
    environment:
      - PORT=${API_GATEWAY_PORT}
      - NODE_ENV=dev
      - PORT_AUTH_SERVICE=${AUTH_SERVICE_PORT}
      - PORT_STORY_SERVICE=${STORY_SERVICE_PORT}
      - PORT_USER_SERVICE=${USER_SERVICE_PORT}
      - PORT_MEDIA_SERVICE=${MEDIA_SERVICE_PORT}
      - PORT_SOCIAL_SERVICE=${SOCIAL_SERVICE_PORT}
      - PORT_NOTIFICATION_SERVICE=${NOTIFICATION_SERVICE_PORT}
    develop:
      watch:
        - action: sync
          path: ./services/api-gateway
          target: /app
          ignore:
            - node_modules/
        - action: rebuild
          path: ./services/api-gateway/package.json
    depends_on:
      auth-service-dev:
        condition: service_healthy
      story-service-dev:
        condition: service_healthy
      # user-profile-service-dev:
      #   condition: service_healthy
    env_file:
      - .env
    networks:
      - frontend
      - backend

  auth-service-dev:
    build:
      context: ./services/auth-service
      dockerfile: Dockerfile.dev
    volumes:
        - ./services/auth-service/prisma:/app/prisma
    ports:
      - "${AUTH_SERVICE_PORT}:${AUTH_SERVICE_PORT}"
    environment:
      - PORT=${AUTH_SERVICE_PORT}
      - NODE_ENV=dev
      - DATABASE_URL=postgresql://${DB_USER}:${DB_PASSWORD}@postgres:5432/storycraft_auth
    develop:
      watch:
        - action: sync
          path: ./services/auth-service
          target: /app
          ignore:
            - node_modules/
        - action: rebuild
          path: ./services/auth-service/package.json
    depends_on:
      postgres:
        condition: service_healthy
    healthcheck:
        test: ["CMD-SHELL", "wget -q --spider http://localhost:${AUTH_SERVICE_PORT}/health > /dev/null 2>&1"]
        interval: 30s
        timeout: 5s
        retries: 5
        start_period: 10s
    env_file:
      - .env
    networks:
      - backend

  user-profile-service-dev:
    build:
      context: ./services/user-profile-service
      dockerfile: Dockerfile
    ports:
      - "${USER_SERVICE_PORT}:${USER_SERVICE_PORT}"
    environment:
      - PORT=${USER_SERVICE_PORT}
      - DB_HOST=postgres
      - DB_PORT=5432
      - DB_USER=${DB_USER}
      - DB_PASSWORD=${DB_PASSWORD}
      - DB_NAME=${DB_NAME}
    develop:
      watch:
        - action: sync
          path: ./services/user-profile-service
          target: /app
        - action: rebuild
          path: ./services/user-profile-service/go.mod
    depends_on:
      postgres:
        condition: service_healthy
    env_file:
      - .env
    networks:
      - backend
  story-service-dev:
      build:
        context: ./services/story-service
        dockerfile: Dockerfile.dev      
      ports:
        - "${STORY_SERVICE_PORT}:${STORY_SERVICE_PORT}"
        - 9323:9323 # Playwright
      volumes:
        - ./services/story-service/prisma:/app/prisma
      environment:
        - PORT=${STORY_SERVICE_PORT}
        - NODE_ENV=dev
        - DATABASE_URL=postgresql://${DB_USER}:${DB_PASSWORD}@postgres:5432/storycraft_story
      develop:
        watch:
          - action: sync
            path: ./services/story-service
            target: /app
            ignore:
              - node_modules/
              - prisma/
          - action: rebuild
            path: ./services/story-service/package.json
      depends_on:
        postgres:
          condition: service_healthy
      healthcheck:
        test: ["CMD-SHELL", "wget -q --spider http://localhost:${STORY_SERVICE_PORT}/health > /dev/null 2>&1"]
        interval: 30s
        timeout: 5s
        retries: 5
        start_period: 10s
      env_file:
        - .env
      networks:
        - backend
</file>

</files>
